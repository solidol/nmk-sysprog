# Функції

[Зміст](../README.md)

## Передача аргументів за значенням
Аргументи можуть передаватися за значенням (by value) та за посиланням (by reference). При передачі аргументів за значенням зовнішній об'єкт, який передається як аргумент у функцію, може бути змінено у цій функції. У функцію передається саме значення цього об'єкта. Наприклад:

```cpp
#include <iostream>
 
void square (int, int);
 
int main()
{
     int a = 4;
     int b = 5;
     std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
     square(a, b);
     std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
 
     return 0;
}
void square(int a, int b)
{
     a = a * a;
     b = b * b;
     std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
}
```
Функція square приймає два числа та зводить їх у квадрат. У функції main перед і після виконання функції square відбувається виведення на консоль значень змінних a і b, які передаються в square як аргументи.

І при виконанні ми побачимо, що зміни аргументів функції square діють тільки в рамках цієї функції. Поза її значенням змінних a і b залишаються незмінними:

Before square: a = 4 b = 5
In square: a = 16 b = 25
After square: a = 4 b = 5
Чому так відбувається? При компіляції функції її параметрів виділяються окремі ділянки пам'яті. При виклику функції обчислюються значення аргументів, які передаються місце параметрів. І потім значення аргументів заносяться до цих ділянок пам'яті. Тобто функція маніпулює копіями значень об'єктів, а чи не самими об'єктами.

## Передача параметрів за посиланням
При передачі параметрів посилання передається посилання на об'єкт, якою ми можемо маніпулювати самим об'єктів, а чи не просто його значенням. Так, перепишемо попередній приклад, використовуючи передачу за посиланням:

```cpp
#include <iostream>
 
void square(int&, int&);
 
int main()
{
     int a = 4;
     int b = 5;
     std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
     square(a, b);
     std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
 
     return 0;
}
void square(int &a, int &b)
{
     a = a * a;
     b = b * b;
     std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
}
```
Тепер параметри a та b передаються за посиланням. Посилальний параметр зв'язується безпосередньо з об'єктом, тому через посилання можна міняти сам об'єкт.

І якщо ми скомпілюємо та запустимо програму, то результат буде іншим:

Before square: a = 4 b = 5
In square: a = 16 b = 25
After square: a = 16 b = 25
Передача посилання дозволяє повернути з функції відразу кілька значень. Також передача параметрів посилання є більш ефективною при передачі дуже великих об'єктів. Оскільки в цьому випадку немає копіювання значень, а функція використовує сам об'єкт, а не його значення.

Від передачі аргументів за посиланням слід відрізняти передачу посилань як аргументи:

```cpp
#include <iostream>
 
void square (int, int);
 
int main()
{
     int a = 4;
     int b = 5;
     int &aRef = a;
     int &bRef = b;
     std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
     square(aRef, bRef);
     std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
 
     return 0;
}
void square(int a, int b)
{
     a = a * a;
     b = b * b;
     std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
}
```
Якщо функція приймає аргументи за значенням, то зміна параметрів усередині функції також ніяк не позначиться на зовнішніх об'єктах, навіть якщо виклику функції до неї передаються посилання на об'єкти.

Before square: a = 4 b = 5
In square: a = 16 b = 25
After square: a = 4 b = 5
Передача параметрів за значенням більше підходить для передачі у функцію невеликих об'єктів, значення яких копіюються у певні ділянки пам'яті, які потім використовує функція.

Передача параметрів за посиланням більше підходить для передачі у функцію великих об'єктів, у цьому випадку не потрібно копіювати весь вміст об'єкта в ділянку пам'яті, за рахунок чого продуктивність програми збільшується.