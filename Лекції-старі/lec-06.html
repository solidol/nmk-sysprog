<!DOCTYPE html>
<html>
<head>
	<title>Системне програмування. Лекція № 6</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
	<div class="paper">
<div id="colontitle">Системне програмування. Лекція № 6</div>
<h1>Рядки як символьні масиви</h1>

<p>

Ефективність мови С++ багато в чому визначається наявністю в ній розвинутих засобів для обробки символьної інформації. У стандартній бібліотеці С++ передбачено багато функцій, що виконують прості дії з символьними даними. Тому ця мова най­краще підходить для системної роботи: написання компіляторів, інтерпретаторів, операційних систем, редакторів тексту тощо.

</p>


<p>

У мові С та в ранніх версіях мови С++ рядки розглядалися як символьні масиви, і вся робота з ними ґрунтувалася на ви­користанні цих масивів. Розроблена бібліотека функцій <strong>string.h</strong> містить потужні засоби для роботи з рядковими масивами. Рядок являє собою масив символів, який закінчується нуль-символом. Нагадаємо, що нуль-символ має код, що дорівнює <strong>0</strong>, і запис у вигляді керуючої послідовності <strong>‘\0’</strong>. За розташуван­ням нуль-символа визначається фактична довжина рядка. Кіль­кість елементів символьного масиву складається з кількості сим­волів у рядку плюс <strong>1</strong>, тому що нуль-символ також є елементом масиву. 
Для опису рядка використовуються звичайні засоби опису масивів, наприклад: <strong>char str [25];</strong>. Індексування такого масиву, як і будь-якого іншого, починається з нуля. 
Символьні послідовності, розділені тільки пропусками, роз­глядаються як один рядок, тобто запис:

</p>


<p ><strong>“Один час сегодня стоит</strong>

</p>


<p ><strong> двух часов завтра”</strong>

</p>


<p>

ідентичний до рядку:

</p>


<p ><strong>“Один час сегодня стоит двух часов завтра”.</strong>

</p>


<p>

Адреса першого символа рядка може використовуватися по- різному:

</p>


<ul>
<li>якщо рядок застосовується при ініціюванні масиву типу <strong>char</strong>, адреса його першого елемента стає синонімом імені маси­ву. Наприклад, ідентичними є такі описи масиву: 
	<strong>char  st [  ] = “Слово”; </strong> 
	<strong>char st [6] = “Слово”; </strong> 
	<strong>char st [6] = {‘С’ ‘л’ ‘о’ ‘в’ ‘о’ ‘\0’};</strong>
</li>

<li> якщо рядок використовується для ініціювання покажчи­ка типу <strong>char *</strong>, адресапершого символа рядка буде початковим значенням покажчика, наприклад: 
	<strong>char  *pst = “Слово”;.</strong>
</li>

</ul>
<p>

Тут описується змінна-покажчик <strong>pst</strong>, яка одержує початко­ве значення, що дорівнює адресі першого елемента (симво­ла<strong> ‘С</strong>‘);

</p>


<ul>
<li> якщо рядок використовується у виразі, що застосовує покажчик, то компілятор підставляє у вираз рядка адресу його першого символа, наприклад:</li>

</ul>
<p>

<strong>char  *pst;</strong> 
<strong>pst = “Первый символ”;.</strong> 
Тут <strong>pst</strong> одержує адресу символа <strong>«П»</strong> (тобто першого символа рядка). 
Слід звернути увагу на те, що при описі символьного масиву його ім’я — не змінна, а покажчик-константа на початок рядка, тому її не можна використовувати в деяких операціях адресної арифметики. Зокрема, не можна здійснювати операцію присво­ювання вигляду:

</p>


<p>

<strong>char  st [20];</strong> 
<strong> st  = “Петренко”;</strong> — запис неправильний, тому що не можна змінити значення <strong>st</strong>.

</p>


<p>

<strong>Виконання дій з елементами символьного масиву</strong> здійсню­ється через індекси або через покажчики. Для доступу до будь- якого символа рядка використовується індекс масиву <strong>char</strong>. Тоб­то, якщо описана змінна <strong>char str  [3];</strong>, то третім елементом ма­сиву можна скористатися, записавши: <strong>str [2] або *(str +2)</strong>. 
<strong>У процесі роботи з елементами двовимірного масиву</strong> засто­совують або індекси масиву, або індекси покажчиків. Якщо описаний список прізвищ <strong>char spis  [5] [15];</strong>, то для використан­ня символа масиву слід записати: <strong>spis [і][j] або *(spis [і] + j )</strong>. 
Аналогічно, якщо оголошений масив покажчиків <strong>char *str  [5]</strong>, що містить 5 елементів, кожний з яких вказує на рядок, то до­ступ до символа рядка можна здійснити з використанням запи­су <strong>*(str [і] + j )</strong>.

</p>





<h2>Введення-виведення символьних масивів</h2>

<p>
Введення рядків можна здійснювати різними способами, найбільш розповсюдженими з яких є:
</p>

<ul>
<li>введення шляхом ініціювання при оголошенні символь­них масивів:</li>

</ul>
<p>
<strong>char st 15] = “Диск”; </strong>
<strong>char st [  ] = “Диск”; </strong>
<strong>char *pst = “Диск”;.</strong>
</p>

<p>
У цьому випадку двовимірні масиви можна ініціювати по-різ­ному, наприклад, у вигяді:
<strong>char str [5][20] = {“Петренко И. И. “Головко С. С. “, . . . ,}; </strong>
<strong>char str [ ][20] = {“Петренко И. И. “, “Головко С. С. . . . ,}; </strong>
<strong>char *pst[5] = {“Петренко И. И. “, “Головко С. С. “, . . . ,}; </strong>
<strong>char *pst[ ] = {“Петренко И. И. “, “Головко С. С. “…….., };</strong>
</p>

<ul>
<li>використання потокового введення <strong>сіn &gt;&gt;</strong>. Здійснюється у випадку, коли рядок не містить пропусків, тому що символ пропуску є роздільником введення даних, наприклад:</li>

</ul>
<p>
<strong>char st [5];  сіn &gt;&gt; st; </strong>
<strong>char *pst;  сіn &gt;&gt; *pst; </strong>
<strong>char str [5][20];  сіn &gt;&gt; str [i]; </strong>
<strong>char *pst [5];  cin &gt;&gt; *(pst [i]);</strong>
</p>

<ul>
<li>посимвольне введення за допомогою функції <strong>get(  )</strong>, на­приклад:</li>

</ul>
<p>
<strong>get (st[i]);</strong>
</p>

<ul>
<li>введення за допомогою функції <strong>cin.get</strong>:</li>

</ul>
<p>
<strong>  cin.get (str[i], size, endl);,</strong>
</p>

<p>
де <strong>size</strong> — кількість символів, що читаються;
</p>

<ul>
<li>введення з використанням функції <strong>cin.getline</strong>:</li>

</ul>
<p>
<strong>  cin.getline (str[i], sizeof (str[i]-l));,</strong>
де <strong>sizeof ()</strong> — функція визначення розміру рядка.
</p>

<p>
Виведення рядкових даних реалізується з використанням стандартного вихідного потоку <strong>cout</strong>:
<strong>cout &lt;&lt; st;</strong>
<strong>cout.write(st, size);</strong> тощо.
</p>

<p>
Для потокового введення-виведення доцільно застосовувати функції <strong>setw(w),setprecision(d), cout.width(w) і cout.precision(d).</strong>
</p>

<p>
Введення-виведення символьних масивів можна здійснити за допомогою відповідних функцій заголовного файла <strong>stdio.h .</strong>, наприклад:
</p>

<ul>
<li>для введення рядків — <strong>gets(st); та scanf (% s,st);</strong></li>

<li>для виведення рядків <strong>—  puts(st);  і  prin,tf(% s,st);.</strong></li>
</ul>


<h2>Основні функції обробки символьних типів</h2>

<p>
У ранніх версіях С++ рядки розглядалися як символьні масиви. Для роботи з ними розроблено бібліотеку функцій <strong>string.h ,</strong> що містить ефективні засоби для роботи з рядками. Згодом була розроблена стандартна бібліотека шаблонів <strong>Stan­dard TemplateLibrary (STL ),</strong> яка надає більш потужні засоби, об’єднані в клас <strong>string</strong>. Але незважаючи на існування цього окремого для рядків класу, символьні масиви, що закінчуються нульовим байтом <strong>‘\0’</strong>, залишаються досить популярними. Це відбувається завдяки їх ефективності і можливості контролю­вання операції з рядками.
</p>

<p>
Для обробки символьних типів даних бібліотека функцій <strong>string.h</strong> має велику кількість вбудованих функцій, що збіль­шують продуктивність праці програмістів та скорочують час на розробку програм, наприклад:
</p>

<ul>
<li>функції перевірки символів;</li>

<li>функції перетворення символів;</li>

<li>функції перевірки рядків;</li>

<li>функції маніпулювання рядками.</li>

</ul>
<p>
Функції наводяться у вигляді списків, що згруповані за їх розташуванням у заголовних файлах. Найчастіше надаються прототипи функцій, що описують, як слід використовувати функції у програмах (<strong> див.  розділ  9 </strong>).
</p>

<p>
Далі розглянемо прототипи, стислий опис, дію та методи­ку застосування основних функцій обробки даних символьно­го типу.
</p>

<p>
 <strong>Функції копіювання рядків</strong>  <strong>:</strong> 
</p>

<ul>
<li><strong>char strcpy (s, *st );</strong> — виконує операцію копіювання байтів рядка <strong>st</strong> у рядок <strong>s</strong>(включаючи  <strong>“\0”</strong>; повертає <strong>s</strong>), на­приклад:</li>

</ul>
<p>
<strong>char str [50];</strong>
</p>

<p>
<strong>strcpy (str, “О деле суди по исходу.”);</strong>
</p>

<ul>
<li><strong>char *strdup (const char *str );</strong> — виконує копіювання рядка <strong>str</strong> і повертає покажчик на рядок-копію, наприклад:</li>

</ul>
<p>
<strong>char “st1 = “Слово — есть поступок.”; </strong>
<strong>char *st2;</strong>
</p>

<p>
<strong>st2 =  strdup (st1);</strong>  //  копируется st1 в st2; 
</p>

<ul>
<li><strong>char *  strncpy (char *st1, const char *st2, int n);</strong> — вико­нує копіювання <strong>n</strong> символів з рядка <strong>st2 у  st1</strong> (рядок <strong>stl</strong> повинен бути більше або дорівнювати <strong>st2</strong>, інакше виникне помилка), на­приклад:</li>

</ul>
<p>
<strong>char st1[ ] = “Паскаль “;</strong>
</p>

<p>
<strong>char st2[ ] = “Привет из далека “;</strong>
</p>

<p>
<strong>strnpy (st1, st2,  3);  </strong>  // st1 — “Прикаль  “. 
</p>

<p>
<strong> Функції, конкатенації рядків : </strong>
</p>

<ul>
<li><strong>char *strcat (char *st1, const char *st2);</strong> — поєднує <strong>st1 і  st2</strong> та повертає <strong>st1</strong>,наприклад:</li>

</ul>
<p>
<strong>char str [100];
	strcpy (str, “Borland “);
strcat (str, ” C++5″);,</strong>
</p>

<p>
у результаті маємо рядок
</p>

<p>
<strong>string = “Borland C++5” ;</strong>
</p>

<ul>
<li><strong>char *strncat (char *st1, const char *st2, int n );</strong> — додає до рядка <strong>st1 n</strong> символів рядка <strong>st 2</strong> і повертає знову в <strong>st1</strong>, на­приклад:</li>

</ul>
<p>
<strong>char st1 [90] = “Привет “;</strong>
</p>

<p>
<strong>char st2 [50] = “студент и студентка”;</strong>
</p>

<p>
<strong>strncat (st1, st2, 7);,</strong>
</p>

<p>
у результаті маємо рядок:
</p>

<p>
<strong>st1 = “Привет студент ” .</strong>
</p>

<p>
 <strong>Функції порівняння рядків</strong>  <strong>:</strong> 
</p>

<ul>
<li><strong>int strcmp (char *stl, char *st 2);</strong> — порівнює рядки <strong>st1 і st 2</strong> та повертає цілу величину, що дорівнює:</li>

</ul>
<p>
<strong>&lt;0 — якщо st1 &lt; st2;</strong>
</p>

<p>
<strong>= 0 — якщо st1 = st2;</strong>
</p>

<p>
<strong>&gt;0 — якщо st1 &gt; st2;,</strong>
</p>

<p>
наприклад:
</p>

<p>
<strong>char st1[ ] = “Слово ” ; </strong>
</p>

<p>
<strong>char st2[ ] = “слово”; </strong>
</p>

<p>
<strong>int k;</strong>
</p>

<p>
<strong>k = strcmp (st1, st2);</strong> //k&lt;0; 
</p>


<ul>
<li><strong>int stricmp (const char *stl, const char *st2); </strong>— виконує порівняння рядків, не враховуючи регістра символів; повертає цілу величину, як і функція <strong>strcmp ()</strong>,наприклад:</li>

</ul>
<p>
<strong>char st1[ ] = “Слово “; </strong>
</p>

<p>
<strong>char st2[ ] = “слово”; </strong>
</p>

<p>
<strong>int k;</strong>
</p>

<p>
<strong>k =  stricmp (st1, st2);</strong>  //  k = 0  ; 
</p>

<ul>
<li><strong>int strncmp (char *stl, char *st2, int n );</strong> — виконує порів­няння рядків із заданою кількістю символів <strong>n у  st1 і st 2</strong> і по­вертає цілу величину:</li>

</ul>
<p>
<strong>&lt;0 — якщо st1 &lt; st2;</strong>
</p>

<p>
<strong>=0 — якщо st1 = st2;</strong>
</p>

<p>
<strong>&gt;0 — якщо st1 &gt; st2;</strong> ;
</p>


<ul>
<li><strong>char *strnicmp (char *stl, char *st2, int n );</strong> — виконує порівняння рядків із заданою кількістю символів <strong>n у  st1 і st 2</strong>, незалежно від регістра, і повертає цілу величину, як і в попе­редньому випадку.</li>

</ul>
<p>
 <strong>Функції перетворення символів рядка</strong>  <strong>:</strong> 
</p>

<ul>
<li><strong>char *strlwr (char*st );</strong> — перетворює символи рядка <strong>st</strong> верхнього регістра в символи нижнього регістра, при цьому ін­ші символи не враховуються. Наприклад:</li>

</ul>
<p>
<strong>char st [ ] = ” Лазерный Принтер”; </strong>
</p>

<p>
<strong>strlwr (st ); </strong> // st = ” лазерный принтер” ; 
</p>



<ul>
<li><strong>char *strupr (char *st );</strong> — перетворює символи рядка <strong>st</strong> нижнього регістра в символи верхнього регістра, інші символи не враховуються;</li>

</ul>
<ul>
<li><strong>char *strrev (char *st );</strong> — записує символи в рядку <strong>st</strong> у зворотному порядку (реверсує рядок), наприклад:</li>

</ul>
<p>
<strong>char st [ ] = ” Hello”; </strong>
</p>

<p>
<strong>strrev (st);</strong>  //  st – ” olleH”; 
</p>


<ul>
<li><strong>char *strchr (char *st, int c );</strong> — визначає перше входжен­ня символа <strong>с</strong> у рядок <strong>st</strong>;повертає покажчик на символ у ряд­ку <strong>st</strong>, що відповідає введеному символу, наприклад:</li>

</ul>
<p>
<strong>char st [90] = ” Borland С++5 ” </strong>
</p>

<p>
<strong>char *spt;</strong>
</p>

<p>
<strong>spt= strchr (st,  ‘+”);</strong> — тепер покажчик <strong>spt</strong> вказує на підрядок <strong>“++5”</strong> рядка <strong>st</strong>;
</p>

<p>
 
</p>

<ul>
<li><strong>char *strrchr (char *st, int c );</strong> — знаходить останнє вхо­дження символа <strong>с</strong> у рядок <strong>st</strong>;якщо символ с у рядку не вияв­лений, повертає <strong>0</strong>, інакше повертає покажчик на останній сим­вол у рядку <strong>st</strong>, що відповідає заданому зразку, наприклад:</li>

</ul>
<p>
<strong>char st [80] = “Borland С++5”; </strong>
</p>

<p>
<strong>char *spt;</strong>
</p>

<p>
<strong>spt= strrchr (st,  ‘+’);</strong> — покажчик <strong>spt</strong> вказує на підрядок <strong>“+5”</strong> ряд­ка <strong>st</strong>.
</p>

<p>
 
</p>

<p>
 <strong>Функції пошуку підрядка в рядку:</strong> 
</p>

<ul>
<li><strong>strspn (const char *st1, const char *st2  );</strong> — повертає кількість символів від початку рядка <strong>st1</strong>, що збігаються із сим­волами рядка <strong>st 2</strong>, де б вони не знаходилися в <strong>st 2</strong>,наприклад:</li>

</ul>
<p>
<strong>char st1 [ ] = “Borland С++5”; </strong>
</p>

<p>
<strong>char st2 [ ] = ” narlBod “; </strong>
</p>

<p>
<strong>int k;</strong>
</p>

<p>
<strong>k= strspn (sti, st 2);</strong> — змінна <strong>k </strong>одержує значення, що дорівнює <strong>8</strong>, тому що перші8 символів рядка містилися в <strong>st1</strong>(враховуючи сим­вол пропуску);
</p>

<ul>
<li><strong>char *strstr (const char *st1, const char *st 2);</strong> — функція шукає в рядку <strong>st1</strong> перше входження <strong>st 2</strong> і повертає покажчик на перший символ, знайдений у <strong>st1</strong>, з підрядка<strong>st 2</strong>; якщо ря­док <strong>st 2</strong> не виявлений в <strong>st1</strong>, функція повертає <strong>0</strong>, наприклад:</li>

</ul>
<p>
<strong>char stl [ ] = “Привет, сокурсник, идем на экзамен”; </strong>
</p>

<p>
<strong>char st2[ ] = “сокурсник”;</strong>
</p>

<p>
<strong>char spt;</strong>
</p>

<p>
<strong>spt = strstr (stl, st2);</strong>
</p>

<p>
Результат виконання:
</p>

<p>
<strong>spt = “сокурсник, идем на экзамен”.</strong>
</p>

<p>
За потреби визначення останнього входження можна спо­чатку реверсувати рядок за допомогою функції <strong>strrew;</strong>
</p>

<p>
 
</p>

<ul>
<li><strong>char *strtok (char *st, const char *dlm );</strong> — розбиття ряд­ка на лексеми (сегменти), обмежені символами, що входять до складу рядка <strong>dim</strong>. Цей параметр може містити будь-яку кіль­кість різних обмежників — ознак границь лексем, після виді­лення лексеми в рядок <strong>st</strong> поміщається символ <strong>«\0»</strong>.</li>

</ul>
<p>
Наступні виклики функції <strong>strtok ()</strong> повинні бути з першим аргументом <strong>NULL .</strong> Бони будуть повертати покажчик на інші, наявні в <strong>st</strong> лексеми. Щоразу після завершення виділення лек­семи у її кінці замість розділового символа поміщається сим­вол<strong> «\0</strong>». Після того, як у рядку не залишиться жодної лексе­ми, функція повертає <strong>NULL</strong>. Для збереження вихідного рядка його треба записати в резервну змінну. Цю функцію зручно використовувати для розбиття речення на слова або будь-які інші сегменти. Розглянемо приклад програми з використан­ням функції <strong>strtok().</strong>
</p>

<p>
 <strong>Приклад 7.1.</strong>  Скласти програму, яка вводить речення, здійснює розбиття його на слова, підраховує кількість символів у кожному сло­ві та виводить відповідну інформацію
</p>

<pre>//  Р7 1.СРР — применение функции strtok(  )  
 /* определение порядкового номера слова в предложении и подсчет количества символов в каждом слове */ 
#include &lt;string.h&gt; 
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
voidmain (void) 
{ char *tk, *spt=", .!";  
  char st[ ] = "Делай великое, не обещая великого.";
  cout &lt;&lt; st&lt;&lt; endl;
  int і = 1;
  tk = strtok (st, spt);
  while (tk != NULL)
 {
  cout &lt;&lt; і &lt;&lt; " слово — " &lt;&lt; tk &lt;&lt; " — содержит " &lt;&lt; strlen(tk) &lt;&lt; " символов" &lt;&lt; endl;
  tk = strtok(NULL, spt); і++;}
 getch ();  // задержка экрана 
}
	</pre>

	<pre>
Результати виконання програми:
Делай великое, не обещая великого.
1  слово — Делай — содержит 5 символов
2  слово — великое — содержит 7 символов
3 слово — не — содержит 2 символов
4 слово — обещая — содержит 6 символов
5  слово — великого — содержит 8 символов
Процес розбиття речення на слова можна було б здійснити з використанням і такого програмного фрагмента:
tk = strtok (st &lt; spt );  // первый вызов функции 
while (tk)
if ((tk = strtok(), spt) != 0) cout &lt;&lt;. . ..
 Для видалення з рядка підрядка  або  символа  із заданої позиції  у бібліотеці string.h немає спеціальної функції, однак можна написати власну, наприклад:
	</pre>

	<pre>
void del (char *st, int k, int n); 
{
  for (int і = k; і &lt; strlen(st); i++)
  st[i] = st [i + n];
  st[i] =’\0′;  // запись “\0” в конец новой строки 
}
де st — вихідний рядок (покажчик на нього);
  n — кількість символів у підрядку, що вилучається;
  k — позиція, з якої треба вилучити підрядок. Наведемо приклад, котрий ілюструє використання функції void del (); (детальніше про функції  див. в розділі 9 ).

	</pre>


	<p>
<strong> Приклад 7.2. </strong> Скласти програму вилучення підрядка в<strong> n</strong> символів з <strong>k</strong>-ої позиції в рядку.
	</p>

	<pre>/*  Р7 2.СРР — удаление подстроки в п символов из k-ой позиции в строке  */
#include &lt;iostream.h&gt; 
#include &lt;string.h&gt; 
#include &lt;conio.h&gt;
 //--------------- функция удаления подстроки из строки 
void del (char*sp, int k, int n)
{ int і;  
  for (і = k; і &lt; strlen(sp); і++)
  sp[i] = sp[i+n]; 
  sp[i] = \0';}
main ()  //----------- главная функция 
{ char st[50], pst[10]; 
	  cout &lt;&lt; "***** Введите строку\n"; 
	  cin.getline(st, 50);
	  cout &lt;&lt; "***** Введите подстроку\n";
	  сіn &gt;&gt; pst;
	  cout &lt;&lt; "Исходная строка: — "&lt;&lt; st &lt;&lt; endl;  
	  del (st, strstr(st, pst)-st, strlen(pst));  
	  cout &lt;&lt; "Новая строка: — "&lt;&lt;st&lt;&lt;endl;  
	  getch();
}
}
</pre>

<pre>
Результата обчислень:
***** Введите строку
Люблю писать программы на языке С++!
***** Введите подстроку
писать
Исходная строка: — Люблю писать программы на языке С++! 
Новая строка: — Люблю программы на языке С++!

</pre>

<ul>
<li><strong>void* memchr (const void *st, int s, int n );</strong> — функція шукає символ <strong>“s “</strong> у рядку <strong>*st </strong>довжиною <strong>n</strong> байт, тобто в блоці пам’яті, на який вказує покажчик <strong>st</strong>. Якщо символ <strong>s</strong>знайде­ний, функція повертає покажчик на цей символ, а в протилеж­ному випадку —повертає <strong>NULL</strong>;</li>


<li><strong>void* memcmp (const void *s1, const void *s2, n );</strong> і <strong>void* memicmp (const void *sl,const void *s2, int count); </strong>— функції по­рівнюють <strong>n</strong> байт з двох буферів, на початок яких указують <strong>s1 і s 2</strong>.</li>

</ul>
<p>
Функції повертають значення
</p>

<p>
<strong>&lt;0 — якщо s1 &lt; s2;</strong>
<strong>=0 — якщо s1 = s2;</strong>
<strong>&gt;0 — якщо s1 &gt; s2; ;
</strong>
</p>

<ul>
<li><strong>char *strset (char *st, int ch, int n );</strong> і <strong>char *strset (char *st, int ch );</strong> — функції заповнюють рядок <strong>st</strong> символом <strong>ch</strong> і по­вертають покажчик на отриманий рядок, <strong>n</strong> —заповнює <strong>n</strong> сим­волів рядка <strong>st.</strong></li>

</ul>
<p>
<strong>Функції перетворення рядків у числа та чисел у рядки знаходяться у файлі stdlib.h:</strong>
</p>

<ul>
<li><strong>int atoi (const char *s);</strong> — перетворює рядок <strong>s</strong> у число типу <strong>int</strong>. Повертає отримане число <strong>0</strong>, якщо зустрінеться сим­вол, що не може бути перетворений. Рядок повинен містити число, наприклад, <strong>«2345»</strong>, та мати таку структуру: <strong>[пропуски] [знак числа] [цифри];</strong></li>

</ul>
<ul>
<li><strong>long atol (const char *s );</strong> — перетворює рядок <strong>s</strong> у число типу <strong>long</strong> <strong>int</strong> <strong>(</strong>аналогічна функції <strong>atoi .</strong>);</li>

</ul>
<ul>
<li><strong>double atof (const char *s );</strong> — перетворює рядок сим­волів у число з плаваючою крапкою типу <strong>double</strong>. Якщо зу­стрічається символ, що не може бути перетворений, повер­тає <strong>0</strong>. Оброблюваний рядок повинен мати таку структуру: <strong>[пропуски] [знак числа] [цифра.цифра] [літера е, Е,  d або D]  [знак порядку] [цифри порядку]</strong>, наприклад, <strong>«-12345.123» або  «-12.345123  ЕЗ»</strong>;</li>

</ul>
<ul>
<li><strong>char *ecvt (double vl, int n, int *dec, int *sign );</strong> — пере­творює число <strong>vl</strong> у рядок символів, кількість яких дорівнює <strong>n</strong> символів цифр. Положення десяткової крапки від першої цифри числа повертається до змінної, на яку вказує <strong>dec</strong>. Знак числа повертається до змінної, на яку вказує <strong>sign</strong>. Якщо <strong>sign  = 0</strong>, то число є додатним, інакше — від’ємним. Отриманий рядок збе­рігається у внутрішній пам’яті функції, покажчик повертається на початок сформованого рядка;</li>

</ul>
<ul>
<li><strong>char *fcvt (double vl, int n, int *dec, int *sign );</strong> — анало­гічна до попередньої функції <strong>char *ecvt ()</strong>, але якщо для функ­ції <strong>ecvt</strong> параметр <strong>dec</strong> задає загальну кількість цифр, то для функції <strong>fcvt</strong> — кількість цифр після десяткової крапки;</li>

</ul>
<ul>
<li><strong>char *gcvt (double vl, int n, char *buf );</strong> — перетворює число <strong>vl</strong> у рядок, котрий поміщає в буфер, покажчик на по­чаток якого є <strong>buf</strong>, <strong>n</strong> — число цифр у символічному записі пе­ретвореного числа. Отриманий рядок містить символ знака чис­ла і десяткової крапки, якщо число містить менше десяткових цифр, ніж <strong>n</strong>. У цьому випадку молодша цифра дробової час­тини відкидається. Якщо перетворене число не можна поміс­ити в задану кількість цифр <strong>n</strong>, функція генерує символьний запис в експоненціальній формі із символом <strong>Е</strong> і знаком по­рядку. Функція повертає покажчик на початок сформовано­го рядка;</li>

</ul>
<ul>
<li><strong>strlen (st )</strong> — повертає довжину змінної <strong>st</strong> без нуль-термінала <strong>«\0»</strong>.</li>

</ul>
<p>
 <strong>Функції перевірки символів знаходяться у файлі ctype.h:</strong> 
</p>

<ul>
<li><strong>isgraph (s )</strong> — повертає значення «істина» (<strong>1</strong>), якщо s є дру­кованим символом, і «неправда» (<strong>0</strong>), якщо <strong>s</strong> є пропуском або яким-небудь не відображуваним символом;</li>

</ul>
<ul>
<li><strong>isprint (s )</strong> — повертає значення «істина» (<strong>1</strong>), якщо s є дру­кованим символом, включаючи символ пропуску, і «неправда» (<strong>0</strong>) у всіх інших випадках;</li>

</ul>
<ul>
<li><strong>ispunct (s )</strong> — повертає значення «істина» (<strong>1</strong>), якщо <strong>s</strong> є зна­ком пунктуації (будь-який друкований символ, крім пропуску), і «неправда» (<strong>0</strong>) в інших випадках;</li>

</ul>
<ul>
<li><strong>isdigit (s) </strong>— повертає значення «істина» (<strong>1</strong>), якщо s є циф­рою від 0 до 9, і «неправда» (<strong>0</strong>) в інших випадках;</li>

</ul>
<ul>
<li><strong>isalmim (s )</strong> — повертає значення «істина» (<strong>1</strong>) якщо s є циф­рою або літерою (заголовною або строковою), і «неправда» (<strong>0</strong>) у всіх інших випадках (тобто перевіряє алфавітні та цифрові символи).</li>

</ul>
<p>
 <strong>Функції перетворення символів:</strong> 
</p>

<ul>
<li><strong>tolower (s )</strong> — перетворює символ s до нижнього регістра;</li>

<li><strong>toupper (s )</strong> — перетворює символ s до верхнього регістра;</li>

<li><strong>atoi (s) </strong>— перетворює рядок s до цілого числа;</li>

<li><strong>atol (s )</strong> — перетворює рядок s до довгого цілого;</li>

<li><strong>atof (s )</strong> — перетворює рядок s до числа з плаваючою крапкою.</li>

</ul>
<p>
 
</p>

<p>
Розглянемо приклади з використанням рядкових функцій.
<strong> </strong>
<strong> Приклад 7.3. </strong> Ввести до пам’яті комп’ютера список прізвищ, які розташовані в будь-якому порядку, та відсортувати їх за алфавітом.
Розглянемо перший варіант (<strong> див.  Р7_3_1.СРР </strong>) реалізації поставленої задачі. Будемо вважати, що вводять прізвища та ініціали, тоді програма може мати вигляд:
</p>

<pre>//  Р7 3 1.СРР — отсортировать фамилии по алфавиту 
#include &lt;iostream.h&gt; 
#include &lt;string.h&gt;
#include &lt;conio.h&gt;
main( )
{ const int n=5;
  char sp[n][l5], r[15];
  int i, k;
 /  /------------------------------- ввод фамилий и инициалов 
cout&lt;&lt;  "***** Введите " &lt;&lt; n &lt;&lt; " фамилий \n"; 
  for (і = 0; і &lt; n; і++)
 { cout&lt;&lt;"Введите "&lt;&lt;(і+1)&lt;&lt;" фамилию и инициалы\n"; 
 cin.getline (sp[i], sizeof (sp[i]) - 1); 
 }
 //------------------------------ сортировка списка фамилий 
  for (k = 1; k &lt; n; k++) 
  for (i = 0; і &lt; n-k; i++)
  if (strcmp (sp[i], sp[i+l])&gt;0) 
  { strcpy (r, sp[i]);
  strcpy (sp[i], sp[i+1]);
  strcpy (sp[i+1], r);}
  cout&lt;&lt;"\n Отсортированный массив фамилий \n";
  for (і = 0; і &lt; n; i++)  
  cout &lt;&lt; sp[i] &lt;&lt; endl;
  getch ();  
}
</pre>

<pre>
Результати обчислень:
******* Введите 5 фамилий
Введите 1 фамилию и инициалы
Иванченко С. И.
Введите 2 фамилию и инициалы
Авдиенко А. Р.
Введите 3 фамилию и инициалы
Яшин Б. Ю.
Введите 4 фамилию и инициалы
Кашкин Т. Б.
Введите 5 фамилию и инициалы
Мельниченко Т. Ю.
Отсортированный массив фамилий
Авдиенко А. Р.
Иванченко С. И.
Кашкин Т. Б.
Мельниченко Т. Ю.
Яшин Б. Ю.
</pre>

<p>
У наведеній програмі використано масив прізвищ <strong>sp  [6][15]</strong> і символьний рядок <strong>r</strong>, який потрібен для тимчасового зберіган­ня прізвища при сортуванні масиву. Для сортування був засто­сований раніше розглянутий метод виштовхування («пухирця») (<strong> див . розділ  6.4 </strong>).
</p>

<p>
Порівняння елементів символьного масиву <strong>(char sp[n ][15])</strong> здійснюється за допомогою функції <strong>strcmp(  )</strong>, а перезапис прі­звищ з одного елемента масиву <strong>sp[i ]</strong> в другий — <strong>sp[i+1 ]</strong>— за допомогою функції <strong>strcpy(  )</strong> і змінної <strong>r</strong>.
</p>

<p>
Після сортування на екран виведено одержаний масив. Другий варіант (<strong> див.Р7_3_2.СРР </strong>) розв’язання поставленої задачі використовує покажчики.
</p>

<pre>/*  Р7_3_2.СРР — сортировка списка фамилий в алфавитном порядке с использованием указателей  */
#include &lt;iostream.h&gt;
#include &lt;string.h&gt;
#include &lt;conio.h&gt;
void main( )
{ const n=5; 
  char sp [n][15];
  int i, k;
  char *ps[n], *ptr ; // ps[n] — массив указателей  
 // ввод фамилий и инициализация массива указателей 
 cout &lt;&lt; "***** Введите фамилии \n"; 
  for (і = 0; і &lt; n; і++) 
  { gets (sp [і]); 
  ps[i] = sp[i];}
 //--------------------------- вывод исходной информации 
  cout &lt;&lt; "\n***** Исходный список\n"; 
  for (і = 0; і &lt; n; і++) 
  puts (ps[i]);
//------------------------------------ сортировка массива
  for (k = 1; k &lt; n; k++) 
  for (i = 0; i&lt;n-k; i++) 
  if (strcmp (ps[i], ps[i+1]) &gt; 0)  
  { ptr = ps[i];  
  ps[i] = ps[i+1];  
  ps[i+1] = ptr; }
 //--------------------- вывод отсортированного массива 
  cout &lt;&lt; "\n\n*****Отсортированный список \n"; 
  for (і = 0; і &lt; n; і++) 
  puts (ps[i]); 
  getch ();  
}
</pre>

<pre>
Результати виконання програми:
***** Введите фамилии 
Игнатенко А. P. 
Головко Н. А.
Долбня Б. В. 
Андриенко С. Ф. 
Ичко Т. В.
***** Исходный список
Игнатеяко А. Р. 
Головко Н. А. 
Долбня Е. В. 
Андриенко С. Ф. 
Ичко Т. В.
***** Отсортированный список
Андриенко С. Ф.
Головко Н. А.
Долбня Е. В.
Игнатенко А. Р.
Ичко Т. В.
 
 Приклад 7.4.  Ввести рядок і видалити в ньому зайві пропуски.
</pre>

<pre>//  Р7 4.СРР — удаление лишних пробелов в строке 
#include &lt;iostream.h&gt; 
#include &lt;string.h&gt; 
#include &lt;conio.h&gt;
void main() 
{ char st[ ] = "Краткость — сестра таланта";
  int і, n  = 0; //n — для подсчета пропусков 
 for (і = 0; і &lt; strlen(st); i++) 
  { if (st[i] != ' ') 
  { cout « st[i];  
 n=0; }  
  else n++; 
  if (n == 1)  
  cout &lt;&lt; st[i]; }
  getch();
}
</pre>

<pre>
Результати виконання програми:
Краткость — сестра таланта
 Приклад 7.5.  Визначити позицію входження підрядка в рядок.
</pre>

<pre>//  Р7 5.СРР — поиск позиции вхождения подстроки в строку 
#include &lt;iostream.h&gt;
#include &lt;string.h&gt;
#include &lt;conio.h&gt;
const int m = 50;
void main() 
{ char *pt, mainstr[m], substr[m];
  int n, k = 0;
  cout &lt;&lt; "***** Введите строку " &lt;&lt; endl;
  cin.getline (mainstr, m);
  cout &lt;&lt; "***** Введите подстроку " &lt;&lt; endl;
  cin.getline (substr, m);
  pt = strstr (mainstr, substr);
  cout &lt;&lt; endl;
  while (pt) 
  { k ++; // номер вхождения  
 n = pt - mainstr;  
  cout &lt;&lt; k &lt;&lt;" -oe вхождение подстроки" &lt;&lt;" номер позиции = "&lt;&lt; n &lt;&lt; endl;
  pt = strstr(++pt, substr);
    cout &lt;&lt; k &lt;&lt; " " &lt;&lt; *pt &lt;&lt; endl;}
  if (k == 0) cout &lt;&lt;"Подстрока не содержится в строке"&lt;&lt;endl;
  getch();
}
</pre>

<pre>
Результат виконання:
***** Введите строку
Почти во всех делах самое трудное — начало. 
***** Введите подстроку 
самое трудное
1-ое вхождение подстроки номер позиции = 20
 Приклад 7.6.  Знайти заданий символ у рядку.
</pre>

<pre>//  Р7 6.СРР — поиск символа в строке 
#include &lt;iostream.h&gt; 
#include &lt;string.h&gt; 
#include &lt;conio.h&gt;
main( )
{ const int m = 50; 
  char sim, *pt, str[m];
  int n, k = 0;
  cout &lt;&lt; "***** Введите строку" &lt;&lt; endl;
  cin.get (str, m);
  cout &lt;&lt; "***** Введите символ" &lt;&lt; endl;
  сіn &gt;&gt; sim;
  pt = strchr (str, sim);
  while (pt)
{ k ++;
    n = pt-str;
  cout&lt;&lt;k&lt;&lt;"-я позиция вхождения символа = "&lt;&lt;n&lt;&lt;endl;
  pt = strchr(++pt, sim); }
cout  &lt;&lt; "Количество вхождений = "&lt;&lt;k&lt;&lt;endl;
  if (k==0) cout &lt;&lt; "Символ не входит в строку" &lt;&lt; endl;
 getch();
}
</pre>

<pre>
Результати обчислень:
***** Введите строку
Алгоритм — фундаментальное понятие информатики 
***** Введите символ 
и
1-я позиция входения символа = 5
2-я позиция входения символа = 32
3-я позиция входения символа = 35
4-я позиция входения символа = 43
5-я позиция входения символа = 45
Количество вхождений = 5
</pre>

<p>
<strong> Приклад 7.7. </strong> З уведеного списку прізвищ (без ініціалів) вилучити такі, що починаються на задану літеру і мають задане закінчення, та вивести повідомлення про прізвище з найменшою кількістю літер.
</p>

<pre>/*  P7_7.CPP — найти фамилии, начинающиеся на заданную букву и имеющие заданноеокончание  */
#include &lt;iostream.h&gt;
#include &lt;string.h&gt;
#include &lt;conio.h&gt; 
main()
{ const int n = 6; 
  char spis [n][15], pok[5], p;
  int i, minfam, k=0;
 //------------------------------ ввод списка фамилий без инициалов 
cout  &lt;&lt; "***** Введите "&lt;&lt;n&lt;&lt;" фамилий\n";
 for (і = 0; і &lt; n; i++)
  сіn &gt;&gt; spis [і];
  cout &lt;&lt; "***** Введите первую букву\n";
  сіn &gt;&gt; р;
  cout &lt;&lt; "**** Введите окончание\n";
  сіn &gt;&gt; роk;
// определение фамилии на заданную букву и на заданное окончание
 cout &lt;&lt; "***** Искомые фамилии\n";
  for (і = 0; і &lt; n; і++)
  if (spis [i][0]==p &amp;&amp; strcmp(strrchr(spis[i], pok[0]), pok)==0) 
  cout&lt;&lt;spis [i]&lt;&lt;endl;
 //-------------- поиск фамилии с наименьшим количеством букв 
  minfam - strlen (spis [0]);
  for (і = 1; і &lt; n; і++)
  if (strlen (spis [і]) &lt; minfam)
  { minfam = strlen (spis[i]);
 k=і; } 
  соut&lt;&lt;"\Фамилия с наименьшим колич. букв — "&lt;&lt;spis [k]&lt;&lt;" \n";
  cout &lt;&lt; "Её длина = " &lt;&lt; strle(spis [k]) &lt;&lt; " символов\n";
  getch ();  
}
</pre>

<pre>
Результати обчислень:
***** Введите 6 фамилий
Андриенко
Коваленко
Степаненко
Курко
Коноваленко 
Перекотиполе
***** Введите первую букву 
К
***** Введите окончание
ко
***** Искомые фамилии
Коваленко
Курко
Коноваленко
Фамилия с наименьшим колич. букв — Курко 
Её длина = 5 символов
</pre>

<p>
У програмі для зберігання першої літери використовується змінна з ім’ям <strong>р</strong>, а для закінчення — змінна <strong>роk</strong>. Вилучення за­кінчення прізвища здійснює функція <strong>strrchr(spis[i],pok [0])</strong>, яка повертає покажчик на останнє входження заданої літери <strong>(рок[0])</strong> у рядок<strong>(spis[i ])</strong>. Потім цей покажчик порівнюється з введеним закінченням прізвища за допомогою функції <strong>strcmp()</strong>. У цілому в операторі <strong>if</strong>… визначається як перша літера, так і закінчення прізвища. Змінна <strong>minfam</strong> існує для знаходження прізвища з най­меншою кількістю літер згідно з алгоритмом визначення мінімального елемента масиву (див. <strong> приклад 1.3 </strong>).
</p>






<h2>Використання рядків типу string</h2>

<p>
Раніше розглядалися питання обробки символьних даних мо­ви С++, у тому числі і символьних рядків. Однак в останніх вер­сіях мови С++, починаючи з С++4.5, введена стандартна бібліо­тека шаблонів — <strong>Standard Template Library (STL )</strong>, яка містить клас <strong>string</strong> з більш потужними засобами обробки рядків.
</p>

<p>
Для підключення цього класу до програми слід записати ди­рективу:
</p>

<p><strong>#include &lt;string &gt;</strong> (без розширення <strong> .h </strong>)
</p>

<p>
і підключити простір імен бібліотеки шаблонів у вигляді
</p>

<p><strong>using namespace std;  .</strong>
</p>

<p>
Після цього можна оголошувати змінні типу <strong>string :</strong>
</p>

<p><strong>  string strl, str2; .</strong>
</p>

<p>
Ініціювання рядків при оголошенні виконується одним із способів:
</p>

<p>
<strong>  string st1 = “Это строка класса string”; </strong>
<strong>  string st2 (“Это другая строка класса string”);.</strong>
Оголошення покажчика на рядок здійснюється так:
<strong>  string *pst;.</strong>
</p>

<p>
Пам’ять для покажчика може бути виділена з будь-яким по­чатковим значенням за допомогою функції <strong>new</strong>, наприклад:
<strong>  string *pstr1 = new string; </strong>— оголошується порожній рядок,
<strong>  string *pstr2 = new string  (“Новая строка”); </strong>— покажчик вказує на рядок «Новаястрока».
</p>

<p>
Раніше оголошеному покажчику <strong>*pst ,</strong> який ні на що не вка­зує, можна присвоїти значення у вигляді
<strong>  pst = new string (“Это первая строка”);.</strong>
</p>

<p>
Значення рядка <strong>string</strong> містить будь-який набір символів, за­писаний у лапках.
</p>

<p>
Для рядків типу <strong>string</strong> визначено такі операції:
</p>

<ul>
<li>конкатенації (приєднання), котрі позначаються симво­лом «+»;</li>

<li>відношення («==», «!=», «&gt;», «&gt;=», «&lt;», «&lt;=»).</li>

</ul>
<p>
Наприклад, фрагмент
<strong>  string st1 = “Динамическая”; </strong>
<strong>  string st2 = “память”; </strong>
<strong>  string st3 = st1+’ ‘+st2; </strong>
<strong>  cout &lt;&lt; st3 &lt;&lt; endl;</strong>
дозволить вивести на екран повідомлення: <strong>Динамическая память.</strong>
</p>

<p>
Для введення рядків <strong>string</strong>, крім операторів присвоювання, застосовують оператори введення даних:
<strong>  сіn &gt;&gt; st;</strong>
<strong>  cin.getline(st, siseof(st));</strong>
<strong>  getline(cin,st, ‘\n’); тощо.</strong>
</p>

<p>
Виведення рядків на екран здійснюється шляхом викорис­тання звичайних операторів виведення даних.
</p>

<p>
Рядки можна об’єднувати у масиви, які оголошуються зви­чайним засобом, тобто
</p>

<p>
<strong>  string sp [10];</strong> — оголошення масиву, що містить 10 рядків.
</p>

<p>
Доступ до символів рядка здійснюється шляхом запису по­рядкового номера символа —індексу, який починається з нуля. Індекси можна записувати як у квадратних дужках, так і у зви­чайних, круглих.
</p>

<p>
Наприклад, якщо записати
<strong>  string str=”Moя строка”;,</strong>
то <strong>str [2]</strong> — це буде літера <strong>‘я’.</strong>
</p>

<p>
Для масивів рядків потрібний символ визначається шляхом запису двох індексів: індексу елемента масиву та індексу сим­волу в цьому елементі, тобто у вигляді <strong>mas[i][j].</strong>
</p>

<p>
Існує багато функцій для обробки рядків типу <strong>string ,</strong> роз­глянемо деякі з них.
</p>

<p>
<strong> Функції визначення довжини рядка: </strong>
</p>

<ul>
<li><strong>str.size(); </strong></li>

<li><strong>str.length();</strong></li>

<li><strong>str.max_size(); .</strong></li>

</ul>
<p>
Наприклад:
</p>

<pre> //--------------------------- определение длины строки 
#include &lt;iostream.h&gt;
#include &lt;string&gt;
using namespace std;
main() 
{ string str, st ="И вот сама пришла волшебница зима!"; 
  str =" волшебница";
  cout &lt;&lt; "Длина строки str = " &lt;&lt; str.size() &lt;&lt; " Длина строки st = " &lt;&lt; st.length() &lt;&lt; endl;
}
</pre>

<p>
Результат виконання:
<strong>Длина строки str =11 Длина строки st = 34</strong>
</p>

<p>
 <strong>Функції додавання одного рядка або його частини до ін­шого рядка:</strong> 
</p>

<ul>
<li><strong>Str.append(st );</strong> — додає рядок <strong>st</strong> до кінця рядка <strong>srt;</strong></li>

<li><strong>Str.append(st,k,n );</strong> — додає до рядка str n символів ряд­ка <strong>st ,</strong> починаючи з позиції <strong>k.</strong></li>

</ul>
<p>
Наприклад:
</p>

<pre> //--------------- добавление строки 
<strong>string str, st = "Substring in text";</strong>
<strong>str.append(st,3,6);</strong>
<strong>cout &lt;&lt; "str = "&lt;&lt;str &lt;&lt; endl;</strong>
</pre>

<p>
Результат виконання:
<strong>str = string</strong>
<strong> Функція включення рядка в рядок : </strong>
</p>

<ul>
<li><strong>str.insert(k,st )</strong> — вставляє в рядок <strong>str</strong> з позиції <strong>k</strong> рядок <strong>st</strong>;</li>

<li><strong>str.insert(k1,st,k2,n )</strong> — вставляє в рядок <strong>str</strong> з позиції <strong>kl</strong> n символів рядка <strong>st</strong>,починаючи з позиції <strong>k2</strong> в рядку <strong>st</strong>.</li>

</ul>
<p>
Наприклад:
 // вставка подстроки в строку 
<strong>string str, st = “string”;    </strong>
<strong>str = “My text”;  </strong>
<strong>str.insert(3,st);  </strong>
<strong>cout &lt;&lt; “str = “&lt;&lt; str &lt;&lt; endl; </strong>
</p>

<pre>
Результат: <strong>str = My string text
</strong>
<strong>string str, st = “string “;</strong>
<strong>str = “My text”;</strong>
<strong>str.insert(3,st,2,4);</strong>
<strong>cout &lt;&lt; ” str = ” &lt;&lt; str &lt;&lt;  endl;</strong>
</pre>

<p>
Результат:<strong> str =  My ring text</strong>
</p>

<p>
<strong> Функція вилучення символів із рядка : </strong>
</p>

<ul>
<li><strong>str.remove(k,n )</strong> — вилучає <strong>n</strong> символів з рядка <strong>str</strong>, почи­наючи з позиції <strong>k</strong>.</li>

</ul>
<p>
Наприклад:
// удаление подстроки из строки
<strong>string str = “My text string”; </strong>
<strong>str.remove(3,4);</strong>
<strong>cout &lt;&lt; “str = “&lt;&lt; str &lt;&lt; endl;</strong>
</p>

<p>
Результат виконання:
<strong>str = My string.</strong>
 <strong>Функція заміни частини рядка або усього рядка:</strong> 
</p>

<ul>
<li><strong>str.replace(st)</strong> — заміняє рядок <strong>str на  st</strong>;</li>

<li><strong>str.replace(k,n,st )</strong> — заміняє в рядку <strong>str  n</strong> символів, по­чинаючи з позиці<strong>ї  k</strong> рядка <strong>st</strong>;</li>

<li><strong>str.replace(kl,nl,st,k2,n 2)</strong> — заміняє в рядку <strong>str nl</strong> сим­волів з позиції <strong>kl</strong> частиною в<strong>n 2</strong> символи рядка <strong>st</strong>, починаючи з позиції <strong>k 2</strong>.</li>

</ul>
<pre>
Наприклад:
//  замена подстроки в строке 
<strong>string str, st = “substring”;   </strong>
<strong>str =”My text string”;   </strong>
<strong>str.replace(8,9,st); </strong>
<strong>cout &lt;&lt;“str = “&lt;&lt; str&lt;&lt;endl;  </strong>
</p>

<pre>
Результат виконання:
<strong>str = My text substring </strong>
<strong>
string str, st = ” substring”;</strong>
<strong>str=”My text long”; </strong>
<strong>str.replace(3,5,st,l,3); </strong>
<strong>cout &lt;&lt;” str = “&lt;&lt; str&lt;&lt;endl;  </strong>
</p>

<pre>
Результат виконання:
<strong>str = My sublong</strong>
<strong> </strong>
<strong> Функція обміну змістом двох рядків: </strong>
</p>

<ul>
<li><strong>str.swap(st )</strong> — обмінює зміст рядків <strong>str та st</strong>.</li>

</ul>
<pre>
Наприклад:
 //————- обмен содержимым строк 
<strong>string str, st=”Coлнечная погода”; </strong>
<strong>str = “Дождливая погода”;</strong>
<strong>str.swap(st);</strong>
<strong>cout &lt;&lt;” str = “&lt;&lt;str&lt;&lt;” st = “&lt;&lt;st&lt;&lt;endl; </strong>
</pre>

<p>
Результат виконання:
<strong>str = Солнечная погода st = Дождливая погода.</strong>
</p>

<p>
 <strong>Функція виділення частини рядка:</strong> 
</p>

<ul>
<li><strong>str.substr(k,n )</strong> — повертає частину рядка <strong>str</strong> в <strong>n</strong> симво­лів, починаючи з позиції <strong>k.</strong></li>

</ul>
<p>
Наприклад:
 //————- выделение части строки 
<strong>string str, st;
	str=”Moй текст string “;
	st=str. substr(4,13);
cout &lt;&lt; ” st = ” &lt;&lt; st &lt;&lt; endl;</strong>
</p>

<p>
Результат виконання:
<strong>st = текст string.</strong>
</p>

<p>
 <strong>Функція пошуку позиції входження підрядка в рядок: </strong> 
</p>

<ul>
<li><strong>str.find(st,k )</strong> — шукає зліва граничну позицію входжен­ня рядка <strong>st</strong> в рядок <strong>str</strong>,починаючи з <strong>k</strong>-ої позиції рядка <strong>str;</strong></li>

<li><strong>str.rfind(st,k )</strong> — шукає справа граничну позицію вход­ження рядка <strong>st </strong>в рядок <strong>str</strong>,починаючи з <strong>k</strong>-ої позиції рядка <strong>str.</strong></li>

</ul>
<p>
Наприклад:
//  позиция вхождения подстроки в строку 
<strong>string str, st=”nopa”;    </strong>
<strong>str=”Oceнняя пора – дождливая пора!”   </strong>
<strong>int p=str.find(st,0);</strong>
<strong>cout &lt;&lt;” p=”&lt;&lt;p&lt;&lt;endl; </strong>
</p>

<pre>
Результат виконання:
<strong>р=8.</strong>
<strong>string str, st=”nopa”;</strong>
<strong>str=”Oceнняя пора – дождливая пора!”
 int p=str.rfind(st,str.length); 
 cout &lt;&lt;” p=”&lt;&lt;p&lt;&lt; endl;</strong>
Результат виконання:
<strong>р=25.</strong>
</pre>

<p>
<strong> Функція присвоювання усього рядка або його частини ін­шому рядку: </strong>
</p>

<ul>
<li><strong>str.assign(st )</strong> — присвоює весь рядок <strong>st</strong> типу <strong>string</strong> або масив <strong>char[  ]</strong> — рядку <strong>str </strong>типу <strong>string;</strong></li>

</ul>
<ul>
<li><strong>str.assign(st,k,n )</strong> — присвоює <strong>n</strong> символів рядка <strong>st</strong> рядку <strong>str ,</strong> починаючи з <strong>k</strong>-ої позиції.</li>

</ul>
<p>
Ці функції можна використовувати для перетворення рядка типу <strong>char</strong> у рядок <strong>string</strong>.Наприклад:
 //————————– присваивание строк 
<strong>char st[ ]=”Пришло жаркое лето!”; </strong>
<strong>string str;</strong>
<strong>cout&lt;&lt;” str = “&lt;&lt; str.assign(st,7,12)&lt;&lt;endl; </strong>
</p>

<pre>
Результат виконання:
<strong>str  = жаркое лето!
</strong>
або
<strong>string str, st=”O, лето красное, любил бы я тебя!”;
cout&lt;&lt;“str = “&lt;&lt; str.assign(st,3,12) &lt;&lt; endl;</strong>
</pre>

<p>
Результат виконання:
<strong>str  = лето красное.</strong>
<strong> Функція порівняння рядків або їхніх частин: </strong>
</p>

<ul>
<li><strong>str.compare(st )</strong> — порівнює рядки <strong>st</strong> та <strong>str</strong> і повертає зна­чення:</li>

</ul>
<p>
<strong>&lt;0 — якщо st &lt; str;</strong>
<strong>=0 — якщо st = str;</strong>
<strong>&gt;0 — якщо st &gt; str;;</strong>
</p>

<ul>
<li><strong>str.compare(st,k,n )</strong> — порівнює n символів рядка <strong>st</strong> з ряд­ком <strong>str ,</strong> починаючи з <strong>k</strong>-ої позиції. Наприклад:</li>

</ul>
<pre>
 //————— сравнение частей строк 
<strong>string str, st=”oв”;</strong>
<strong>str=”Иванов”; </strong>
<strong>if (str.compare(st,4,2)==0) </strong>
<strong>cout&lt;&lt;“str= “&lt;&lt; str &lt;&lt; endl;</strong>
Результат виконання:
<strong>str  = Иванов.</strong>
<strong> Функція перетворення рядка типу string у рядок типу char : </strong>
</pre>

<ul>
<li><strong>str.c_str ()</strong> — перетворює рядок типу <strong>string</strong> у рядок типу <strong>char.</strong></li>

</ul>
<p>
Розглянемо приклади використання наведених функцій при обробці рядків типу <strong>string.</strong>
</p>

<p>
<strong> Приклад  7.9. </strong> Увести до пам’яті комп’ютера будь-який текст, від­окремити в ньому всі слова, вивести їх на екран та визначити найдов­ше слово
</p>

<pre>//  Р7 9.СРР — выделить слова в тексте и найти среди них наибольшее 
#include &lt;iostream&gt;
#include &lt;string&gt;
 #include &lt;conio.h&gt;
using namespace std;
main ()
{ string txt, s1, s1max ;   // shnax — наибольшее слово 
	  int і, k=0, n=0, max=0;
	 //  ---------------- ввод текста 
	 cout &lt;&lt;"***** Enter text\n";
	  getline(cin,txt,'\n');
	  for (i = 0; і &lt;= txt.length()-l; i++) 
	  { if ((txt[i]==' ') || (txt[i]==',') || (txt[i]=='.'))
	  {n ++;  // n — счетчик пропусков и знаков препинания 
	  if (n&gt;1) continue; k++; // k — счетчик слов 
	  cout&lt;&lt; k &lt;&lt;" slovo - "&lt;&lt; s1&lt;&lt;" = "&lt;&lt;s1.size() &lt;&lt; " simbols\n"; 
	 //--------------- определение слова с наибольшим количеством символов 
	 if (sl.size() &gt; max) 
	  { max = sl.size(); 
	  slmax=sl; } 
	  sl=""; //  освобождение sl для формирования слова 
} 
  else  {n=0; sl=sl+txt[i]; }  //переменная s1 — формирует слово 
  }
  cout&lt;&lt;"\nslmax — "&lt;&lt; slmax&lt;&lt;" = "&lt;&lt;slmax.size()&lt;&lt;" simbols\n"; 
  getch ();
}
</pre>

<pre>
Результати обчислень:
<strong>***** Enter text</strong>
<strong>Учитель, воспитай ученика, чтобы было у кого учиться. </strong>
<strong>1 slovo — Учитель = 7 simbols</strong>
<strong>2 slovo — воспитай = 8 simbols</strong>
<strong>3 slovo — ученика = 7 simbols</strong>
<strong>4 slovo — чтобы = 5 simbols </strong>
<strong>5 slovo — было = 4 simbols</strong>
<strong>6 slovo — у = 1 simbols</strong>
<strong>7 slovo — кого = 4 simbols</strong>
<strong>8 slovo — учиться = 7 simbols</strong>
<strong>slmax — воспитай = 8 simbols.</strong>
</pre>

<p>
У програмі текст вводиться за допомогою функції <strong>getline ()</strong> (зверніть увагу на її вигляд), слова виділяються не з викорис­танням функцій, а шляхом конкатенації символів, якщо вони не є символами-роздільниками.
<strong> Приклад 7.10. </strong> Увести список прізвищ і відсортувати його за ал­фавітом
</p>

<pre>//  Р7_10.СРР — сортировка фамилий по алфавиту 
#include &lt;iostream.h&gt;
#include &lt;string&gt;
#include &lt;conio.h&gt;
using namespace std;
main() 
{ const n=5;
  string spis[n];
  int i, k;
 //--------------------------- ввод списка фамилий 
  for(i = 0; і &lt; n; i++)
  { cout&lt;&lt;"*"** Enter "&lt;&lt;(i+l)&lt;&lt;" name\n";
  getline(cin,spis[i],'\n');  }
//--------------------------- сортировка списка фамилий
  for (k = 1; k &lt; n; k++) 
  for (і = 0; і &lt; n-k; i++)  
  if (spis[i] &gt; spis[i+l]) spis[i].swap(spis[i+l]);
 //--------------------------- вывод отсортированного списка 
 cout&lt;&lt;"\n***** Rezult spisok\n";  
  for(i = 0; і &lt; n; i++) 
  cout &lt;&lt; (i+1) &lt;&lt; ' ' &lt;&lt; spis[i] &lt;&lt; endl; 
  getch ();
}
</pre>

<pre>
Результати виконання:
***** Enter 1 name 
Котин С. Б.
***** Enter 2 name 
Бобров М. Т.
***** Enter 3 name 
Авдеев P. Л.
***** Enter 4 name 
Попов Г. Д.
***** Enter 5 name 
Елкин П. P.
***** Rezult spisok
1 Авдеев P. Л.
2 Бобров M. Т.
3 Елкин П. Р.
4 Котин С. Б.
5 Попов Г. Д.
</pre>

<p>
Для порівняння прізвищ у програмі використовується зви­чайна операція «&gt;», а для взаємозаміни — функція <strong>swap ()</strong> (<strong> про­аналізуйте програми прикладу  7.10 і прикладу  7.4 </strong>).
</p>







<h2>Контрольні запитання</h2>
<ol>


<li>Що таке рядки та значення елементів символьного типу?</li>

<li>Що являє собою масив символьного типу?</li>

<li>Як здійснюється введення символьних даних?</li>

<li>Як виконується порівняння даних символьного типу?</li>

<li>Наведіть приклад використання операції конкатенації.</li>

<li>Як визначити кількість символів у рядку?</li>

<li>Які функції мови С++ необхідні для виділення підрядка з рядка?</li>

<li>Які функції здійснюють перевірку символів?</li>

<li>Як виконується перетворення рядків у числа і навпаки?</li>

<li>Охарактеризуйте функції пошуку підрядка в рядку.</li>

<li>Які функції здійснюють перевірку символів?</li>

<li>Як можна здійснити видалення підрядка з рядка або символа із заданої позиції?</li>

<li>Які інструкції треба записати, щоб підключити бібліотеку шаб­лонів STL до програми?</li>

<li>Які операції можна здійснити з рядками типу string?</li>

<li>Як можна ініціювати рядки типу string?</li>

<li>Як можна визначити символ у рядках типу string?</li>

<li>Як здійснюється ініціювання покажчика на рядок типу string?</li>


</ol>
	</div>
</body>
</html>