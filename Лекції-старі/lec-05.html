<!DOCTYPE html>
<html>
<head>
	<title>Системне програмування. Лекція № 5</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
	<div class="paper">
		<div id="colontitle">Системне програмування. Лекція № 5</div>
		<h1>МАСИВИ У С++</h1>
		<h2>Використання масивів</h2>

<p>
На практиці часто виникає необхідність в обробці даних у вигляді довільного набору значень, тобто масивів. <strong>Масив</strong> являє собою кінцеву іменовану послідовність величин од­ного типу, які розрізняються за порядковим номером. Опис ма­сивiв у програмі відрізняється від опису простої змінної наявніс­тю після імені квадратних дужок <strong>«[ ]»</strong>, в яких задається кількість елементів масиву (розмірність). Слід нагадати, що <strong>у мові C++ нумерація елементів масиву починається з 0.</strong>
</p>

<p>
Розглянемо одновимірні масиви, оголошення яких допус­кае одну з таких форм запису:
</p>

<pre>
&lt;тип&gt; &lt;ім’я&gt; [n];
&lt;тип&gt; &lt;ім’я&gt; [n] = {значення};
&lt;тип&gt; &lt;ім’я&gt; [] = {значення};

</pre>

<p>
При оголошенні одновимірного масиву, коли масив відразу iніціюється, можна не вказувати його розмір. Якщо ж ініціюван­ня не здійснюється під час оголошення масиву, то кількість ін­дексів слід задати обов’язково константним виразом. Наприклад:
</p>

<p>
float m [6];
float m [6] = {3.4, 4.5, 5.6, 6.7, 8.9, 10.3};
float m [  ] = {3.45, 4.56, 5.67, 6.78);
</p>

<p>
Зрозуміло, що надалі кількість елементів змінити немож­ливо. Для того щоб обнулити елементи оголошеного масиву, достатньо ініціювати його перший елемент: <strong>int mas[0]={0};</strong>.
</p>

<p>
За замовчуванням, якщо в оголошеному масиві ініціюється тільки декілька перших елементів, то його інші елементи ініціюються нулями. Так, у випадку, коли <strong>float mas[10]= {2.2,34.56};</strong>, останні вісім елементів масиву одержать значення<strong> 0</strong>.
</p>

<p>
Проiлюструємо використання одновимірних масивів на конкретних прикладах.
</p>

<p>
<strong>Приклад 6.1.</strong> Обчислити функцію <strong>у = ax<sub>i</sub><sup>2</sup> &#8211; sinx<sub>i</sub></strong> аргументи якої <strong>x<sub>j</sub></strong> &#8211; елементи одновимірного масиву, що мають значення:
</p>

<p style="text-align: center;"><strong>х<sub>0</sub> = -0,81; x<sub>1</sub> = -0,58; х<sub>2</sub> = -0,11; х<sub>3</sub> = 0,2; х<sub>4</sub> = 0,91; x<sub>5</sub> = 1,83.</strong>
</p>

<p>
Схему алгоритму і програмну реалізацію цієї задачі наведе по на <strong>рис. 6.1.</strong> Алгоритм передбачає введення значень одновимірного масиву <strong>x<sub>i</sub> (і = 0&#8230;n-l), n = 6</strong> та подальше застосування їx для обчислення функції.
</p>

<p>
У програмі спочатку описується масив дійсних значень : <strong>float х[n].</strong> Введення елементів масиву здійснюється у циклі:
</p>

<p style="text-align: center;">[medium]http://cpp.dp.ua/uploads/posts/2015-12/1450709122_6_1.png[/medium]
</p>

<p>
 Цей цикл містить операцію потокового введення <strong>cin &gt;&gt; x[i];,</strong> перед якою знаходиться пiдказка <strong>cout &lt;&lt; &#8220;х[ &#8221; &lt;&lt; і &lt;&lt; &#8220;] =&#8221;;</strong> для вказiвки номера елемента <strong>x[i]</strong>. Особливість виконання операцii введення <strong>cin &gt;&gt; x[i];</strong> полягає в такому: зустрiвши її у програмi, комп&#8217;ютер призупинить виконання програми, поки не буде введене значення еле­мента<strong> х[і]</strong> і натиснута клавіша <strong>Enter</strong>, пiсля чого робота програми буде продовжена. Зазначена операцiя введення повторюється <strong>n</strong> разiв для забезпечення введення всiх елементiв масиву.
</p>

<p>
Оскільки у С++ індексація елементiв масиву починается з нуля, то масив <strong>float x[6] (n = 6)</strong> iз шести елементiв включае идексованi елементи <strong>x[0], x[1], x[2], &#8230;, x[5].</strong> Програма (<strong>див.P6_1_1.CPP</strong>)  використовуе два цикли: один &#8211; для введення ма­сиву, інший — для обчислення функції. Операцii введення елементів масиву та обчислення значень функції можна здiйсніити в одному циклi(<strong>див. P6_1_2.СРР</strong>).
</p>

<pre>
/* Р6_1_2.СРР — ввод элементов одномерного массива и вычисление функции осуществляется в одном цикле */
#include &lt;iostream.h&gt;
#include &lt;math.h&gt;
#include &lt;conio.h&gt;
main ( )
{ const int n = 7;
  float x[n], y, a(10.5);
  int i;
  for (i = 0;i&lt; n;i++)
  {
    cin &gt;&gt; x[i];        //ввод елемента массива
    y = a * x[i] * x[i] - sin(x[i]);
//--------------------------------------- вывод результата
   cout &lt;&lt; " x["&lt;&lt;i&lt;&lt;"] ="&lt;&lt;x[i]&lt;&lt;" y = " &lt;&lt; y &lt;&lt; endl;
 }
getch ();
}
</pre>

<pre>
Результати обчислень:
-0.81 -0.58 -0.11  0.2  0.91  1.83
x[0] = -0.81     у = 7.61334
х[1] = -0.58     у = 4.08022
х[2] = -0.11     у = 0.236828
x[3] = 0.2        у = 0.221331
x[4] = 0.91      у = 7.90555
х[5] = 1.83      у = 34.1969
</pre>

<p>
У цьому випадку передбачено введення елементів масиву в рядок, і клавішу <strong>Enter</strong> слід натиснути в кiнцi процесу введення.
</p>

<p>
<strong>Приклад 6.2.</strong> Сформувати масив<strong> с<sub>k</sub></strong>, який містить однакові елемен­ти двох масивів <strong>а<sub>і</sub> (і = 0&#8230;n-1), n = 7 та b<sub>j</sub> (j = 0&#8230;m-1), m = 10.</strong> Масиви<strong> а і b</strong> не мають елементів, що повторюються.
</p>

<p>
Схему алгоритму і програмну реалізацію задачі наведено на <strong>рис. 6.2</strong>.
</p>

<p style="text-align: center;">[medium]http://cpp.dp.ua/uploads/posts/2015-12/1450709815_6_1_1.png[/medium]
</p>

<p>
Цей приклад розв’язується з використанням вкладених цик­лів. Процес порівняння елементів відбувається немов у &#8220;три руки&#8221;. Одна рука за параметром <strong>і</strong> вибирає елемент з масиву <strong>а<sub>і</sub></strong>, друга за параметром <strong>j</strong> вибирає елемент з масиву <strong>b<sub>j</sub></strong>, а третя за параметром <strong>k </strong>розташовує вибраний елемент у масив с<strong><sub>k</sub></strong>.
</p>

<p>
Спочатку<strong> і = 0</strong> (відбувається порівняння з <strong>а<sub>0</sub></strong>), a <strong>j</strong> змінюється від<strong> 0</strong> до <strong>m-1</strong>.
</p>

<p>
У циклі за параметром  <strong>j</strong> кожний елемент <strong>bj</strong> порівнюється з <strong>a<sub>i</sub></strong> доти, поки не знайдеться <strong>a<sub>i</sub> = b<sub>j</sub></strong> та не буде переглянутий весь масив <strong>b<sub>j</sub></strong>. Якщо <strong>a<sub>i</sub> = b<sub>j</sub></strong>, то <strong>b<sub>j</sub></strong> заноситься до поточного еле­мента масиву<strong> с<sub>к</sub></strong>.
</p>

<p>
Далі повторюються аналогічні порівняння для <strong>і (і = 1, 2,&#8230;, n-l)</strong>, тобто здійснюється порівняння елементів масиву <strong>bj</strong> з на­ступним елементом масиву <strong>a<sub>i</sub></strong>.
</p>

<p>
<strong>Приклад 6.3.</strong> За один перегляд масиву <strong>c<sub>і</sub>(і = 0&#8230;n-l), n = 15</strong> визна­чити значення, а також положення максимального і мінімального йо­го елементів та поміняти їх місцями.
</p>

<p>
Схему алгоритму розв’язання задачі та пояснення до неї наведено у <strong>прикладі 1.3</strong> (<strong>див. рис. 1.3</strong>).
</p>

<pre>
/* Р6_3.СРР — определение максимального и минимального элементов массива c[n] и перестановка их местами */
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;  
const n=15;
void main ()
{   //описание массива с[n] и его инициализация
  float с[n] = {6.4, 1.5, -5.6, 3.7, 18.9, 10.3, -0.6, 44.5,-0.2, 8.9, 55.3, 6.9, 4.3, 7.7, 10.9};
  float max, min;       // максим, (max) и миним. (min) элементы
int imax, imin;        // индексы искомых элементов
//--------------------------вывод заданного массива с[n]
  cout &lt;&lt; " ***** massiv c[n] ***** n= " &lt;&lt; n &lt;&lt; endl;
  for (int і = 0; і &lt; n; і++) 
  cout &lt;&lt; с[і] &lt;&lt; " ";
/* определение максимального и минимального элементов массива и их индексов — imax, imin */ 
 max = min = c[0];
  imax = imin = 0;
  for (int i =1; i&lt;n; i++)
  {
    if (c[i] &gt;max)
 { max = c[i];
      imax = i; }
    else
    if (с[і] &lt; min)
    { min = с[і];
      іmin = і; }
  }
//------------------------------ перестановка max и min элементов
  c[imin] = max;
  c[imax] = min;
//-------------------------------- вывод max, min, imax, imin
  cout &lt;&lt; ”\n\t max=  " &lt;&lt; max &lt;&lt; " min= " &lt;&lt; min &lt;&lt; endl;
  cout &lt;&lt; "\t imax= " &lt;&lt; imax+1 &lt;&lt; " imin= " &lt;&lt; imin+1 &lt;&lt; endl;
//-------------------------------- вывод преобразованного массива c[n]
  cout &lt;&lt; " **** Rezult massiv ****” &lt;&lt; endl;
  for (int і = 0; і &lt; n; i++)
  cout &lt;&lt; c[i] &lt;&lt; " " ;
  getch ();       // задержка экрана
}
</pre>

<p>
Результати обчислень:
</p>
<pre>
***** massiv c[n] ***** n= 15
6.4 1.5 -5.6 3.7 18.9 10.3 -0.6 44.5 -0.2 8.9 55.3 6.9 4.3 7.7 2.1 
max= 55.3          min= -5.6                                                          imax= 11           іmin= 3 
**** Rezult massiv ****
6.5 1.5 55.3 3.7 18.9 10.3 -0.6 44.5 -0.2 8.9 -5.6 6.9 4.3 7.7 2.1      
</pre>

<p>
Крім одновимірних масивів, тобто таких, де позиція еле­мента визначається за допомогою одного індексу, у практиці розв’язання задач часто застосовуються багатовимірні масиви. У них позиція елемента визначається записом декількох індек­сів. Найбільш розповсюджені <strong>двовимірні масиви</strong> або матриці. Матриці являють собою порядковий запис декількох однови­мірних масивів. Місце розташування кожного елемента визна­чається за допомогою двох індексів — номера рядка і номера стовпця, тобто порядкового номера в рядку. Індекси двовимір­них масивів записуються в квадратних дужках і нумерація ін­дексів починається з нуля <strong>(0)</strong>.
</p>

<p>
Наприклад, двовимірний масив цілих чисел <strong>int а[3][4]</strong>, що має три рядки та чотири стовпці, представлений на <strong>рис. 6.3</strong>
</p>

<table style="margin-left: auto; margin-right: auto; height: 68px;" border="2" width="353">
<tbody>
<tr>
<td width="152">а[0][0]</td>
<td width="160">а[0][1]</td>
<td width="151">а[0][2]</td>
<td width="151">а[0][3]</td>
</tr>
<tr>
<td width="152">а[1][0]</td>
<td width="160">а[1][1]</td>
<td width="151">а[1][2]</td>
<td width="151">а[1][3]</td>
</tr>
<tr>
<td width="152">а[2][0]</td>
<td width="160">а[2][1]</td>
<td width="151">а[2][2]</td>
<td width="151">а[2][З]</td>
</tr>
</tbody>
</table>
<p style="text-align: center;">Рис. 6.3. Вигляд двовимірного масиву (матриці) int а[3][4]
</p>

<p>
У пам’яті комп’ютера масив розташовується безперервно за рядками:
</p>

<p>
<strong>а [0][0], а [0][1], а [0][2], а [0][3], а [1][0], а [1][1], а [1][2], а [1][3], &#8230; а [2][3].</strong>
</p>

<p>
Двовимірні (і багатовимірні) масиви оголошуються так:
</p>
<pre>
	int mas [2][5] ={ 1, 5, 3, 7, 4,10, 11, ІЗ, 14, 25 };
int mas [  ][5] ={ 1, 5, 3, 7, 4, 10, 11, 13, 14, 25 };
int mas [  ][5] ={ { 1, 5, 3, 7, 4 },{10, 11, 13, 14, 25} };
</pre>


<p>
тобто масив задається або списком елементів у тому порядку, и якому вони розташовані у пам’яті, або подається як масив ма­сивів, кожний з яких поміщається в свої фігурні дужки<strong>«{}»</strong>. При оголошенні і одночасному ініціюванні багатовимірних ма­сивів можна опускати кількість індексів тільки першого виміру. Якщо ініціювання не здійснюється під час оголошення масиву, то кількість індексів треба вказувати явно.
</p>

<p>
<strong>Для здійснення введення-виведення, а також для обробки елементів двовимірного масиву у програмі слід передбачати організацію двох циклів</strong>: один — для задання значень індексу рядків, другий — індексу стовпців.
</p>

<p>
<strong>Приклад 6.4.</strong> Кожний елемент матриці <strong>М(3,4)</strong> збільшити на задане число.
</p>

<pre>
// Р6_4. СРР — увеличение элементов матрицы на заданное число
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
main()
{
  const int n = 3, m = 4;      /* n и m - количество строк и столбцов матрицы */
  float М [n][m], z = 10;      // z — заданное число
  int і, j;
//-------ввод элементов матрицы и увеличение их значений на z
  cout &lt;&lt; "**** Vvod matrix " &lt;&lt; endl;
  for (і = 0; і&lt;n; i++)
    for (j = 0; j&lt;m; j++)
 { cout &lt;&lt; " M [" &lt;&lt; і &lt;&lt; "]" &lt;&lt; "[" &lt;&lt; j &lt;&lt; "]=";
      cin &gt;&gt; M [i][j];
      M [i][j] += z;            // M [i][j]= M [i][j] + z;
   }
//-------вывод полученной матрицы в естественном виде
  cout &lt;&lt; "\n\n***** Rezult matrix: ";
 for (і = 0; і &lt; n; і++)
  { cout &lt;&lt; endl;   
    for (j = 0; j &lt; m; j++)  
    cout &lt;&lt; M [i][j] &lt;&lt; " “;}
 getch();       // задержка экрана
}
</pre>

<p>
Результати виконання програми:
</p>
<pre>
***** Vvod matrix 
М [0][0]=4.5 
М [0][1]=6.7 
М [0][2]=4.8 
М [0][3]=23.6 
М [1][0]=5.7 
М [1][1]=3.7 
М [1][2]=2.9 
М [1][3]=6.1 
М [2][0]=1.2 
М [2][1]=4.5 
М [2][2]=4.6 
М [2][3]=2.7
***** Rezult matrix:
14.5   16.7   14.8   33.6
15.7   13.7   12.9   16.1
11.2   14.5   14.6   12.7
</pre>

<p>
У програмі при описі матриці <strong>float M[n][m];</strong> вказується діа­пазон змiни двох iндексiв, перший з яких призначений для iн­дексування рядків <strong>(і)</strong>, другий — для індексування стовпців <strong>(j)</strong>. Введення, обробка і виведення елементів матриці здійснюються за допомогою двох циклів, один з яких є вкладеним в іншій. Це дозволяє при кожному значенні змінної <strong>і </strong>перебирати всі значення змінної <strong>j</strong>. Розглянута програма може бути скорочена шляхом об’єднання всіх трьох блоків циклу в один, але в такс­му випадку вона буде менш наочною.
</p>

<p>
<strong>Приклад 6.5.</strong> Елементи головної та побічної діагоналей матри­ці <strong>С(4,4)</strong> поміняти місцями. Визначити максимальний елемент пере­твореної матриці, а також номери рядка та стовпця, на перетині яких він знаходиться.
</p>

<p>
Схему алгоритму до прикладу наведено на <strong>рис. 6.4.</strong>
</p>

<p style="text-align: center;">[medium]http://cpp.dp.ua/uploads/posts/2015-12/1450812241_6_1_2.png[/medium]
</p>

<p>
Програму розроблено з використанням алгоритму знахо­дження максимального елемента масиву та його індексів (<strong>див. приклад 1.3</strong>).
</p>

<pre>
//P65.CPP — перестановка элементов главной и побочной диагоналей
//--------- определение максимального элемента матрицы и его индексов
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
void main ()
{ const int n = 4;
  int і, j, imax, jmax;
 float max, C[ ][n] = {  {3.6, 8.9, 1.9, 5.8},
                {8.8, 4.1, 1.2, 6.3},
                {2.5, 6.4, 0.1, 5.5},
                {8.8, 4.1, 1.2, 6.3} };   //инициализация С[n][n]
//-------------------------------- вывод исходной матрицы в естественном виде
 cout &lt;&lt; " ***** massiv C[n][n] *****"; 
  for (i = 0; i &lt; n; i++)
  { cout &lt;&lt; endl;
    for (j = 0; j &lt; n; j++)
    cout &lt;&lt; C[i][j] &lt;&lt; " "; }
//--------------------------- перестановка элементов главной и побочной диагоналей
  float rab;          // вспомогательная переменная для перестановки
  for (i = 0; i &lt; n; i++)     // for (i = 0, j = n-1; i &lt; n; i++, j--)
 { j = n-1-i;                    // { rab = C[i][i];
  rab = C[i][i];                //C[i][i]=C[i][j];
C[i]|i] =C[i][j];             //C[i][j] = rab; }
C[i][j] = rab; }
//----------------------------- вывод преобразованной матрицы
 cout&lt;&lt;"\n\n ***** REZULT massiv ***** ";
  for (i = 0; i &lt; n; i++)
  { cout &lt;&lt; endl; 
    for (j = 0; j &lt; n; j++) 
    cout &lt;&lt; C[i]|j] &lt;&lt; "   "; }
// определение max элемента матрицы его индексов — imax, jmax 
  max = С[0][0];
  imax = jmax = 0;  
  for (i = 0; i &lt; n; i++)   
    for (j = 0; j &lt; n; j++)
      if (С[i][j] &gt; max)
      { max = C[i][j];   
        imax = i; jmax = j; }
  cout &lt;&lt; "\n\n max= " &lt;&lt; max &lt;&lt; "  index stroki = " &lt;&lt; imax+1 &lt;&lt; “ index stolbca = “&lt;&lt; jmax+1;
  getch();
}
</pre>

<p>
Результати обчислень:
</p>
<pre>
***** massiv C[n][n] *****
3.6  8.9  1.9  5.8
8.8  4.1  1.2  6.3
2.5  6.4  0.1  5.5
8.8  4.1  1.2  6.3
***** REZULT massiv *****
5.8  8.9  1.9  3.6
8.8  1.2  4.1  6.3
2.5  0.1  6.4  5.5
6.3  4.1  1.2  8.8
max = 8.9 index stroki = 1 index stolbca = 2 .
</pre>



<h2>Покажчики та масиви</h2>

	<p>
<strong>Покажчики</strong> — це змінні, котрі містять адресу пам’яті, роз­поділеної для об’єкта відповідного типу. Усі змін­ні, розглянуті до цього, зберігали якісь значення (дані). Ці дані могли бути різних типів: символьного, цілого, дійсного тощо. При оголошенні змінної-покажчика слід вказати тип даних, адресу яких буде містити змінна, та ім’я покажчика з симво­лом «*».
</p>

<p>
Загальний формат опису покажчика має вигляд:
</p>

<blockquote><p>
<strong>тип *ім’я;</strong>
</p>
</blockquote>
<p>
де <strong>тип</strong> — тип значень, на який вказує покажчик;
<strong>ім’я</strong> — ім’я змінної-покажчика;
«*» — операція над типом, що читається «покажчик на тип».
</p>

<p>
Наприклад:
</p>

<pre>
int *рn; // покажчик на ціле значення;
float *pf1, *pf2; // два покажчики на дійсні значення.
</pre>

<p>
Покажчики не прив’язують дані до якого-небудь визначе­ного імені змінної і можуть містити адреси будь-якого неімено­ваного значення. Існує адресна константа <strong>NULL</strong>, що означає порожню адресу.
</p>

<p>
Слід нагадати, що мова C++ налічує лише дві операції, які стосуються адрес змінних, а саме:
</p>

<p>
<strong>«&amp;»</strong> — <strong>операція взяття адреси</strong> («адреса значення»);
</p>

<p>
<strong>«*»</strong> — <strong>операція розіменування</strong> («значення за адресою»).
</p>

<p>
Операція взяття адреси <strong>«&amp;»</strong> застосовується разом зі змін­ною і повертає адресу цієї змінної. Операція розіменування «*» використовується разом з покажчиками і вилучає значення, на яке вказує змінна-покажчик, розташована безпосередньо після символа «*».
</p>

<p>
Оголошення покажчиків можна здійснити одним з таких способів:
</p>

<pre>
&lt;тип&gt; *ptr;
&lt;тип&gt; *ptr = &lt;змінна-покажчик&gt;;
&lt;тип&gt; *ptr = &amp;&lt;ім’я змінної&gt;;
</pre>

<p>
Наприклад:
<strong>int *ptx, b; float у;</strong> — оголошені змінна-покажчик <strong>ptx</strong> та змінні <strong>b і у</strong>;
</p>

<p>
<strong>float *sp = &amp;у;</strong> — покажчику <strong>sp</strong> присвоюється адреса змінної <strong>у</strong>;
</p>

<p>
<strong>float *р = sp;</strong> — покажчику <strong>р</strong> присвоюється значення (адреса зна­чення), яке міститься в змінній <strong>sp</strong>, тобто адреса змінної <strong>у</strong>.
</p>

<p>
При оголошенні покажчиків символ «*» може знаходитися перед ім’ям покажчика або відразу після оголошення типу по­кажчика і поширювати свою дію тільки на одну змінну-покаж­чик, перед якою він записаний:
</p>

<p>
<strong>long *pt;   long*Uk;   int *ki, x, h; </strong>— оголошення описів.
</p>

<p>
За потреби для опису покажчика на комірку довільного типу замість ідентифікатора типу записується слово <strong>void</strong>, а саме:
</p>

<p>
<strong>void *р, *pt;</strong> — опис двох покажчиків на довільний тип даних.
</p>

<p>
<strong>Перед використанням покажчика у програмі його обо­в&#8217;язково необхідно ініціювати</strong>, іншими словами, необхідно присвоїти адресу якого-небудь даного, інакше можуть бути не­передбачені результати.
</p>

<p>
Для одержання доступу до значення змінної, адреса якої зберігається в покажчику, досить у відповідному операторі про­грами записати ім’я покажчика з символом «*» — здійснити операцію розіменування.
</p>

<p>
Розглянемо фрагмент програми з поясненнями:
</p>

<p>
<strong>int *р, *р1; </strong>— оголошені два покажчики на комірку пам’яті типу <strong>int</strong>;
</p>

<p>
<strong>int х = 12, у = 5, m[7]; </strong>— оголошені змінні <strong>х</strong>, <strong>у</strong> і масив <strong>m</strong>, змінні ініційовані;
</p>

<p>
<strong>р = &amp;у; </strong>     // р (&amp;у); — покажчику <strong>р</strong> присвоєна адреса змінної <strong>у</strong>.
</p>

<p>
Якщо для цього фрагмента програми записати оператор ви­ведення у вигляді
</p>

<p>
<strong>cout &lt;&lt; &#8220;Адрес р &#8221; &lt;&lt; р &lt;&lt; &#8220;Значение по этому адресу = &#8221; &lt;&lt; *р;,</strong>
</p>

<p>
то виведеться адреса комірки пам’яті, де записана змінна<strong> у</strong> і зна­чення цієї змінної (<strong>тобто 5</strong>).
</p>

<p>
Використовуючи запис<strong> х = *р;</strong>, одержимо <strong>х = 5</strong>, тому щo <strong>*р = у = 5;</strong>.
</p>

<p>
Змінити величину параметра <strong>у</strong> можна так:
</p>

<pre>
у = 10;          // *Р= 10;
*р = *р+5;    //у +=5;.
</pre>

<p>
Остання операція означає збільшення значення змінної у цi­лого типу на <strong>5</strong>, тобто <strong>у= 15</strong>.
</p>

<p>
При ініціюванні покажчиків їм можна присвоювати або адресу об’єкта (змінної), або адресу конкретного місця пам’яті (масиву), або число 0 (нуль), а саме:
</p>

<pre>
int *pt = (char *) 0x00147; // — присвоюється адреса комірки;
int *arrpt = new int [10]; // — визначається початкова адреса розмі­щення динамічного масиву;
char *р = 0; // — здійснюється ініціювання нулем.
</pre>

<p>
Оскільки покажчики — це спеціальні змінні, то в операці­ях з іншими покажчиками вони можуть використовуватися без символа «*», тобто без розкриття посилання, наприклад:
</p>

<pre>
float *pt1, *pt2, х=15, m[5];
pt1 = &amp;x; 
pt2 = pt1;
pt1 = m;         //pt1 = &amp;m[0];
де  m — ім’я масиву, що розглядається як спеціальний покаж­чик-константа.
</pre>

<p>
<strong>Приклад 6.6.</strong> Написати ілюстраційну програму з використанням покажчиків.
</p>

<pre>
// P6_6.CPP — применение указателей 
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
int main ( )
{ int x = 10;
  int *px (&amp;x);   // int *px = &amp;x;
cout &lt;&lt; "x =" &lt;&lt; x &lt;&lt; endl; 
  cout &lt;&lt; "*px =" &lt;&lt; *px &lt;&lt; endl;
  x *= 2;          //x=x*2;
  cout &lt;&lt; "Новое значение *px = " &lt;&lt; *px &lt;&lt; endl;*
  px += 2;       // *px=*px + 2;
  cout &lt;&lt; "Результат *px, т. e. x = " &lt;&lt; x &lt;&lt; endl;
  getch();     //задержка экрана
}
</pre>

<p>
Результат виконання програми:
</p>
<pre>
х = 10 
*рх = 10
Новое значение *рх = 20 
Результат *рх, т. е. х = 22
</pre>

<p>
Для змінної-покажчика існує своя адреса і тому будуть до цільними записи:
</p>

<pre>
int *pt1, *pt2;
</pre>

<p>
<strong>pt1 = (int*) &amp;pt2;</strong> — покажчику <strong>pt1</strong> присвоюється адреса пам&#8217;ятi де розташована змінна <strong>pt2</strong>.
</p>

<p>
Це має сенс у випадку, коли
</p>

<pre>
int у, *pt1, *pt2 = &amp;у;
pt1 = (int*) &amp; pt2;
</pre>

<p>
Обмеження на застосування операції взяття адреси:
</p>

<ul>
<li>не можна визначати адресу літеральної константи (оскіль­ки для неї не виділяється комірка пам’яті), тобто такий запис, як <strong>vp = &amp;345;</strong> — неприпустимий;</li>
<li>не можна визначати адресу результату арифметичного виразу, тобто запис <strong>vp = &amp;(x + y);</strong> теж неприпустимий.</li>
</ul>
<p>
<strong>Дозволені операції для змінних-покажчиків:</strong>
</p>

<ul>
<li>операція розіменування «*»;</li>
<li>операція взяття адреси «&amp;»;</li>
<li>операція присвоювання «=»;</li>
<li>операції інкремент «++» і декремент « &#8211;»;</li>
<li>операції додавання «+» і віднімання «-»;</li>
<li>операції відношення (порівняння) покажчиків однакового типу: «==», «!=», «&lt;», «&lt;=», «&gt;», «&gt;=».</li>
</ul>
<p>
У мові C++ масиви і покажчики зв’язані між собою: <strong>ім’я масиву визначається як покажчик-константа на початковий (нульовий)елемент масиву.</strong> Так, наприклад, при оголошенні одновимірного масиву у вигляді <strong>int mas [20];</strong> його ім’я <strong>mas</strong> &#8211; покажчик на адресу початкового елемента масиву <strong>&amp;mas[0]</strong>.
</p>

<p>
Існує два способи доступу до елементів масиву:
</p>

<ul>
<li>з використанням індексу елемента масиву, наприклад, <strong>mas[2]</strong> або <strong>mas[i];</strong></li>
<li>з використанням адресного виразу, тобто виразу з по­кажчиком на масив, наприклад, <strong>*(mas + 2)</strong> або <strong>*(mas + і)</strong>.</li>
</ul>
<p>
Ім’я покажчика на масив можна записати так:
</p>

<pre>
int mas [20];
int *ptr1;
ptr1 = mas;      //ptr1 = &amp;mas[0];,
</pre>

<p>
тут вирази <strong>&amp;mas[0] і mas</strong> — еквівалентні.
</p>

<p>
Оскільки в комп’ютері для масивів завжди є суцільний блок комірок пам’яті, в яких розташовуються їх елементи, то адресу наступного елемента <strong>mas[1]</strong> можна вказати шляхом збільшення покажчика на <strong>1</strong>, а саме:
</p>

<p>
<strong>р = &amp;mas[0];</strong>
</p>

<p>
<strong>р++;           </strong> //р=р  + 1;
</p>

<p>
Таким чином, адреса <strong>і</strong>-го елемента визначається як <strong>р + і</strong>. При цьому з урахуванням типу масиву і відведеної кількості байтів для кожного його елемента автоматично виконується операція збiльшення адреси, тобто:
</p>

<p>
<strong>адреса х[і] = адреса х[0] + i*sizeof (тип); </strong>.
</p>

<p>
Слід зауважити, що <strong>для покажчиків, які посилаються на елементи масивів різних типів, результат арифметичних операцій і операцій відношення невизначений.</strong>
</p>

<p>
До двох покажчиків <strong>р1 і р2</strong>, що вказують на елементи од­ного масиву, застосовують операції відношення: «==», «!=», «&lt;», «&lt;=», «&gt;», «&gt;=». При цьому значення покажчиків роз­глядаються як цілі числа, а результат порівняння дорівнює<strong> 0</strong> ( »неправда») або <strong>1</strong> («істина»). Так, відношення вигляду <strong>р1&lt;р2</strong> є «істина», якщо <strong>р1</strong> указує на більш ранній елемент, ніж <strong>р2</strong>. Будь-який покажчик можна порівняти з нулем.
</p>

<p>
В арифметиці з покажчиками можна використовувати ад­ресу неіснуючого «наступного за масивом» елемента. До покаж­чиків можна додавати або віднімати від них цілу величину.
</p>

<p>
В обох випадках результатом операції буде покажчик на вихід­ний тип, значення якого на вказане число елементів більше або менше вихідного. Тобто, якщо до покажчика <strong>р</strong> можна додати деяку цілу величину <strong>n</strong>, а саме: <strong>р + n</strong>, то цей вираз визначає ділянку об’єкта, що займає <strong>n</strong>-не місце після об’єкта, на який вказує <strong>р</strong>, при цьому <strong>n</strong> автоматично збільшується на коефіцієнт, що дорівнює відповідній довжині об’єкта. Наприклад, якщо <strong>int</strong> займає 4 байти, то цей коефіцієнт дорівнює чотирьом.
</p>

<p>
Допускається також операція віднімання покажчиків, що вказують на елементи одного масиву. Так, якщо <strong>р1 &lt; р2</strong>, то <strong>р2 &#8211; р1 + 1</strong> — це число елементів масиву від <strong>р1</strong> до <strong>р2</strong> включно.
</p>

<p>
Наведемо приклади програм роботи з покажчиками.
<strong>Приклад 6.7.</strong> Обчислити середнє значення додатних елементів одновимірного масиву.
</p>

<p>
Розглянемо перший варіант програмної реалізації цієї задачі <strong>(див. Р6_7_1.СРР)</strong>.
</p>

<pre>
/* Р671.СРР — вычисление среднего значения положительных элементов массива */
//---------------- программа без использования указателей
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
main( )
{ const int n = 10;
  float mas[n], s = 0;
  int i, kol = 0;
  cout &lt;&lt; "Ввод массива " &lt;&lt; endl;
  for(i =0; і &lt; n; i++)
    cin &gt;&gt; mas[i]; 
      for(i = 0; і &lt; n; i++)   
        if (mas[i] &gt; 0)  
{ s += mas[i];           //накопление суммы
          kol++;  //подсчет положительных елементов
        }
 cout.precision(3 ) ; 
  cout &lt;&lt; "Средн. арифм. полож. элементов = " &lt;&lt; s/kol &lt;&lt; endl; 
 getch();         //задержка экрана вывода резулътата
}
</pre>

<p>
Результати виконання програми:
</p>
<pre>
Ввод массива
1.56 -4.78 6.5 7.89 -3.6 9.45 7.4 -8.43 9.3 -10.2
Средн. арифм. полож. элементов = 7.02
</pre>

<p>
Використовуючи ім’я масиву як покажчик на початок масиву (перший елемент), можна навести другий варіант програми <strong>(див. Р6_7_2.СРР)</strong>:
</p>

<pre>
// Р6_7_2.СРР - использование имени массива как указателя
#indude &lt;iostream.h&gt;
#include &lt;conio.h&gt;
main ( )
{ const int n = 10;  
  float mas[n], s;  
  int i, kol = 0;
  for (і = 0, s = 0; і &lt; n; i++)
  { сіn &gt;&gt; *(mas+i);
    if (*(mas+i) &gt; 0)
     { s += *(mas+i);
       kol++; }  
  } 
  cout.precision(3); 
  cout &lt;&lt;"\n Среднее арифм. полож. элементов = " &lt;&lt; s/kol &lt;&lt; endl; 
  getch();
}
</pre>

<p>
Якщо описати покажчик і зв’язати його з масивом (адре­сувати на початок масиву), то з використанням арифметики покажчиків можна написати третій варіант <strong>(див. Р6__7_З.СРР)</strong> цiєї програми.
</p>

<pre>
// Р6_7_3. СРР — использование арифметики указателей
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
main ( )
{ const int n = 10;
  int і, kol(0);
  float mas[n], s(0);
  float *pm = mas;         //pm= &amp;mas[0];
for (і = 0; і &lt; n; i++)  
  { cout &lt;&lt; "Введите" &lt;&lt; і &lt;&lt; "элемент mas" &lt;&lt; endl;
    cin &gt;&gt; *pm++;
    cout &lt;&lt; mas[i] &lt;&lt; endl;
    if (mas[i] &gt;0) 
    { s += mas[i]; 
      kol++; }  
  }
  cout.precision(3);
  cout &lt;&lt; "\n Среднее арифм. полож. элементов = " &lt;&lt; s/kol &lt;&lt; endl;
  getch();
}
</pre>

<p>
У цій програмі для введення масиву застосований покажчик <strong>*рm</strong>, а для роботи з масивом — ім’я масиву з індексом.
</p>

<p>
В останньому випадку використання покажчика <strong>*рm</strong> призвело б до помилкового результату, оскільки цей покажчик в опера­ціях введення збільшує свою адресу <strong>(рm++)</strong> після введення чергового елемента масиву і надалі вказує на ще не введений елемент.
</p>

<p>
Наведемо четвертий варіант<strong> (Р6_7_4.СРР) </strong>програмної реалiзації прикладу:
</p>

<pre>
/* Р6_7_4.СРР — использование указателей
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
main ( )
{ const int n = 10;
  float mas[n], s = 0;
  float *pm = &amp;mas[0];     //pm *= &amp;mas[0];
 int i, kol = 0;
  for (і = 0; і &lt; n; i++)
  { cout &lt;&lt; "Введите" &lt;&lt; і &lt;&lt; "элемент mas" &lt;&lt; endl;
    cin &gt;&gt; *pm; 
    if (*pm &gt;0)
    { s += *pm; 
      kol++; 
      pm++; }  
  }
  cout.precision(3);
  cout &lt;&lt; ”\n Среднее арифм. полож. элементов = " &lt;&lt; s/kol &lt;&lt; endl;
 getch();
}
</pre>


			<h2>Масиви покажчиків</h2>

			<p>
Подібно до інших змінних, покажчики можна групувати в масиви, кожен з елементів яких містить адресу рядка масиву да­них у пам’яті. Такий спосіб дозволяє зберігати дані з рваними краями, наприклад, деяку текстову інформацію (<strong>див. рис. 6.5</strong>) Масив з «рваними» краями схожий на двовимірну таблицю, ряд­ки якої можуть мати різну довжину. Використання масиву по­кажчиків (<strong>char *fio[ ]</strong>) для збереження рядків дозволяє заоща­джувати пам’ять, а процес обробки рядків виконується значно швидше, бо змінюються тільки покажчики, а не вміст рядків.
</p>

<p>
<strong>Приклад 6.8.</strong> Заданий масив з рваними краями (<strong>див. рис. 6.5</strong>) Навести програмну реалізацію виведення такої інформації з викорис­танням масиву покажчиків.
<a href="/uploads/posts/2015-12/1450816903_6_3.png"><img loading="lazy" class="aligncenter size-medium" src="/uploads/posts/2015-12/1450816903_6_3.png" width="495" height="212" /></a>
</p>

<pre>
// P6_8.CPP — использование массива указателей
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
main ( )
{ char *fio[ ] = { "Петренко",
                   "Головко",
                   "Корж",
                   "Куц",
                   "Юшко",
                   "Плющ" };    // инициализация массива указателей
 int str;
  for (str = 0; str &lt;=5; str++)
  cout &lt;&lt; " stroka " &lt;&lt; (str + 1) &lt;&lt; " = " &lt;&lt; *(fio + str) &lt;&lt; endl;
  getch();        // для задержки экрана вывода результата
}
</pre>

<p>
Результати виконання програми:
</p>
<pre>
stroka 1 = Петренко
stroka 2 = Головко
stroka 3 = Корж
stroka 4 = Куц
stroka 5 = Юшко
stroka 6 = Плющ
</pre>
<p>
Нa рис. 6.5 представлено зв’язок масиву покажчиків char *fio[ ] з відповідними текстовими рядками.
</p>

<p>
Особливістю масиву покажчиків є те, що кожний з його елементів може вказувати на масив довільної довжини. Iснуе можливість записати двовимірний масив чисел і як мат­рицю, і як одновимірний масив покажчиків.
</p>

<pre>
 int matr[5][7];
 або
int *pmt[5];
</pre>

<p>
При цьому двовимірний масив розглядається як одновимір­ний масив рядків, кожен елемент якого — це теж масив стовп­цiв, тобто масивмасивів, тому індексування елементів матриці записуется у вигляді <strong>mas[i][j]</strong>.
</p>

<p>
Звернення до елемента <strong>mas [i][j]</strong> може здійснюватися так:
</p>

<pre>
          *(pm[i] +j)
          або
*(*(рm + і) + j) .
</pre>

<p>
<strong>Приклад 6.9.</strong> Сформувати матрицю цілих чисел <strong>С(5,5),</strong> елементи якої обчислюються за формулою <strong>С<sub>ij</sub> = i+j</strong>. Підрахувати добуток елемен­тiв, розташованих нижче побічної діагоналі, та обнулити ці елементи. Вивести на екран елементи, розташовані в трикутниках нижче голов­ної та вище побічної діагоналей.
</p>

<p>
Перший варіант програмної реалізації даної задачі (<strong>див. Р6_10_1.СРР</strong>) передбачає, що матриця описується явним спосо­бом і робота ведеться з її елементами.
</p>

<pre>
// Р6_9_1.СРР — программа без использования указателей
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
const int n = 5;
int main()
{ int i, j, C[n][n];
  int Pr;          // Pr —     переменная для подсчета произведения
//------------------- формирование матрицы С[n][n]
 cout &lt;&lt; "------ Матрица С[n][n]: \n";
  for (і = 0; і &lt; n; i++)
  { for (j = 0; j &lt; n; j++)
   { C[i][j]=i+j;
     cout &lt;&lt; C[i][j] &lt;&lt; " " ;
   } 
   cout &lt;&lt; endl;
 }
/* вычисление произведения (Pr) элементов ниже побочной диагонали и их последующее обнуление */
  Pr = 1;       //начальное значение Рr
 for (і = 0; і &lt; n; i++)
    for (j = n - і; j &lt; n; j++)
    { Pr*= C[i][j];
      C[i][j] = 0; }
//-------------- вывод па экран полученных результатов
  cout &lt;&lt; "\n Произведение ниже побочной диагон. = " &lt;&lt;Рг &lt;&lt; endl;
  cout &lt;&lt; "\n-------- Преобразованная матрица \n";
  for (і = 0; і &lt; n; i++)
  { for (j = 0; j &lt; n; j++)
    cout &lt;&lt; C[i][j] &lt;&lt; " ";
    cout &lt;&lt; endl; }
//---------------------- вывод элементов ниже главной диагонали
  cout &lt;&lt; "\n Элементы ниже главной диагонали ";
  for (і = 0; і &lt; n; i++)
  { for (j=0; j&lt;n; j++)
    if (j &lt; i) cout &lt;&lt; C[i][j] &lt;&lt; " ";
    else cout &lt;&lt; " " ;
    cout &lt;&lt; endl;  }
//--------------------- вывод элементов выше побочной диагонали
  cout &lt;&lt; "\n Элементы выше побочной диагонали \n";
  for (і = 0; і &lt; n; i++)
  { for (j = 0; j &lt; n; j++)
    if (j &lt; n-1-i) cout &lt;&lt; C[i][j] &lt;&lt; " ";
    else cout &lt;&lt; " ";
    cout &lt;&lt; endl; }
   getch();
   return 0;
}
</pre>

<p>
Результати обчислень:
</p>
<pre>
&#8212;&#8212;&#8211;Матрица C[n]|n]:
0 1 2 3 4
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
4 5 6 7 8
Произведение ниже побочной диагон. = 52920000
&#8212;&#8212;&#8211; Преобразованная матрица
0 1 2 3 4
1 2 3 4 0
2 3 4 0 0
3 4 0 0 0
0 0 0 0 0
Элементы ниже главной диагонали
1
2 3
3 4 0
4 0 0 0
Элементы выше побочной диагонали
0 1 2 3
1 2 3
2 3
3
</pre>

<p>
Другий варіант програмної реалізації (<strong>див.</strong> <strong>Р6_9_2.СРР</strong>) використовує масив покажчиків:
</p>

<pre>
// Р6_9_2.СРР — формирование и обработка матрицы
//-------------- используется массив указателей
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
const int n = 5;
int main()
{ int i, j, Pr, C[n][n], *pm[n];
//---------------- инициализация массива указателей
  for (і = 0; і &lt; n; і++)
  pm[i] = &amp;C[i][0];
//--------------- формирование матрицы С[n][n]
  cout &lt;&lt; " Матрица C[n][n]"&lt;&lt; endl;
  for (i = 0; і &lt; n; i++)
    for(j = 0; j &lt; n; j++) 
    *(pm[i] + j) = i+j;
//------------------ вывод матрицы
 for (i = 0; i &lt; n; i++)
  { for (j = 0; j &lt; n; j++)
    cout &lt;&lt; *(pm[i] + j) &lt;&lt; " ";
cout &lt;&lt; endl; }
/* вычисление произведения (Pr) элементов ниже побочной диагонали и их последующее обнуление */
 Pr = 1;
  for (i = 0; i &lt; n; i++)
    for (j = n-i; j &lt; n; j++)
    { Pr*=*(pm[i] + j);
      *(pm[i]+j) = 0; }
//------------ вывод на экран полученных результатов
 cout &lt;&lt; endl &lt;&lt;" Произведение ниже побочной диагон. = " &lt;&lt; Pr &lt;&lt; endl;
  cout &lt;&lt; endl &lt;&lt; " Преобразованная матрица " &lt;&lt; endl;
  for (і = 0; і &lt; n; i++)
    { for (j = 0; j &lt; n; j++) 
      cout &lt;&lt; *(pm[i] + j) &lt;&lt; " ";
      cout &lt;&lt; endl; }
//----------------- вывод элементов ниже главной диагонали
cout &lt;&lt; endl &lt;&lt; " Элементы ниже главной диагонали"; 
  for (і=0; і &lt; n; і++)  
  { for (j = 0; j &lt; n; j++)
    if (j &lt; i) cout &lt;&lt; *(pm[i] + j) &lt;&lt; ' ';
    else cout &lt;&lt; " ";
    cout &lt;&lt; endl;}
  cout &lt;&lt; endl;
//------------ вывод элементов выше побочной диагонали
  cout &lt;&lt; endl &lt;&lt; " Элементы выше побочной диагонали " &lt;&lt; endl;
  for (і = 0; і &lt; n; і++)  
  { for (j = 0; j &lt; n; j++)
    if (j &lt; n-1-i) cout &lt;&lt; *(pm[i] +j) &lt;&lt; ' ';
    else cout &lt;&lt; " ";
    cout &lt;&lt; endl; }
   getch();
  return 0;
}
</pre>

<p>
У розглянутій програмі для виведення матриці можна ви­користати інший вигляд оператора виведення, наприклад:
<strong>cout &lt;&lt; ( (j = = 0) ? &#8216;\t&#8217;: &#8216; &#8216;)&lt;&lt; *(pm[i] +j) &lt;&lt; ((j= =n)? &#8216;\n&#8216;:&#8217; &#8216;);.</strong>
</p>

<p>
<strong>Ім&#8217;я двовимірної матриці є покажчиком-константою на масив покажчиків-констант, кожний з елементів якого вка­зуе на початок відповідного рядка матриці.</strong> Наприклад, для матриці <strong>mat[2][2]</strong> маємо:
<strong>mat [0]</strong> — покажчик-константа на нульовий рядок матриці;
<strong>mat [1]</strong> — покажчик-константа на перший рядок матриці;
<strong>mat [2]</strong> — покажчик-константа на другий рядок матриці;,
тобто:
<strong>mat [0] = = &amp;mat [0][0];</strong>
<strong>mat [1] = = &amp;mat [1]|0];</strong>
<strong>mat [2] = = &amp;mat [2][0];.</strong>
Виведення матриці можна реалізувати з використанням од­ного з наведених нижче операторів, наприклад:
<strong>cout &lt;&lt; mat[i][j];</strong>
<strong>cout &lt;&lt; *(mat [і] + j);</strong>
<strong>cout &lt;&lt; *(*(mat + і) + j);.</strong>
<strong>Приклад 6.10.</strong> Задана матриця <strong>a<sub>ij</sub> (i = 1&#8230;n, j = 1&#8230;m) n = 3, m = 4</strong>, необхідно її парні елементи переписати до масиву <strong>b</strong>, а непарні — до масиву <strong>с</strong>.
</p>

<p>
Алгоритм розв’язання цієї задачі наведено у <strong>прикладі 1.6</strong>
</p>

<pre>
/* Р6_10.СРР — формирование массивов четных и нечетных элементов */
// использование имени массива как указателя на его начало
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
const int n = 3, m = 4;
void main ()
{ int a[n][m], b[m*n], c[m*n], i, j, kc = 0, kn = 0;
// kc и kn — счетчики подсчета четных и нечетних элементов
//-------------------- ввод исходной матрицы а[n][m]
  cout &lt;&lt; " Vvod massiva a[n][m] " &lt;&lt; endl;
  for (і = 0; і &lt; n; i++)
    for (j = 0; j &lt; m; j++)
    cin &gt;&gt; *(*(a+i)+j);
//------------ формирование массивов b[ ] и c[ ]
for (i = 0; і &lt; n; i++)
    for (j = 0; j &lt; m; j++)
    if (*(*(a+i)+j)%2 == 0) *(b+kc++) = *(*(a+i)+j);
    else *(c+kn++) = *(*(a+i)+j);
//—-------- вывод массива b[] — четных элементов
  cout &lt;&lt; endl &lt;&lt; "massiv chetn. elementov — b[ ] " &lt;&lt; endl;
  for (і = 0; і &lt; kc; i++) 
  cout &lt;&lt; *(b+i) &lt;&lt; " ";
  cout &lt;&lt; endl;
//----------------- вывод массива c[ ] — нечетных элементов
cout &lt;&lt; endl &lt;&lt; "massiv nechetn. elementov — c[ ]" &lt;&lt; endl;
  for (і = 0; і &lt; kn; i++)
  cout &lt;&lt; *(c+i) &lt;&lt; " ";
  cout &lt;&lt; endl;
//------------------  вывод исходной матрицы a[n][m] в естественном  виде
 cout &lt;&lt; endl &lt;&lt; "ishodny massiv";
  for (і = 0; і &lt; n; і++)
  { cout &lt;&lt; endl;
    for (j = 0; j &lt; m; j++)
    cout &lt;&lt; *(*(a+i)+j) &lt;&lt; " "; }
   getch();
}
</pre>

<p>
Результати обчислень:
</p>
<pre>
Vvod massiva a[n][m]
8 2 4 -1
6 1 0 -5
2 9 3 -1
massiv chetn. elementov — b[ ] 
8 2 4 6 0 2
massiv nechetn. elementov — c[ ] 
-1 1 -5 9 3 -1
ishodny massiv
8 2 4 -1
6 1 0 -5
2 9 3 -1.
</pre>

<p>
У C++ можна описати змінну, що має <strong>тип «покажчик на</strong> <strong>покажчик»</strong>. Ознакою такого типу є повторення символа «*» при описі змінної, тобто <strong>int **pmt;</strong>.
</p>

<p>
Пам’ять для такої змінної не виділяється. Її треба привести до відповідного масиву. При описі покажчик на іпокажчик можна ініціювати:
</p>
<pre>
int х = 20;
int *px1 = &amp;х;
int **рх2 = &amp;рх1;
int ***рхЗ = &amp;рх2;.
Доступ до змінної х здійснюється одним з трьох, способів:
*рх1;
 **px2;
 ***рхЗ;.
</pre>

<p>
Для доступу до пам’яті через покажчики на покажчики використовуються як символи «*», так і індекси. Наприклад, іеквівалентими будуть такі посилання на змінну<strong> х</strong>:
</p>
<pre>
*px1;               //рx1 [0];
**рх2;             //рх2 [0][0];
***рхЗ;           //рхЗ [0][0][0];.
</pre>



<h2>Сортування масивів</h2>

<p>
<strong>Сортування масиву</strong> — один з найбільш розповсюджених процесів обробки даних. Завдяки йому здійснюється розміщеня об&#8217;ектів у визначеному порядку, наприклад, чисел за зростанням або за спаданням їх значень, прізвищ у алфавітному порядку тощо. Існують різні методи сортування, серед них — обмінне сортування (метод «пухирця», «шейкер-сортування), сортування вибором, сортування вставками, швидке сортування, сортування Шелла, пірамідальне сортування, сортування обчисленням адреси, сортування порозрядним групуванням тощо. Ці методи відрізняються швидкістю отримання результату, складністю і універсальністю.
</p>

<p>
Розглянемо три методи сортування: обміном, вибором та вставками. Названі методи легко описуються у формі чітких алгоритмiв і передбачають нескладну програмну реалізацію, крім того вони цікаві тим, що моделюють природну поведінку люди­ни, яка здійснює сортування вручну. З іншого боку, вказані ме­тоди не досить ефективні і використовуються у випадках, коли необхідно відсортувати масиви невеликого розміру.
</p>

<p>
<strong>Обмінне сортування</strong> проілюструємо простим сортуванням обмiном — <strong>методом «пухирця»</strong>, який здійснюється шляхом перестановки елементів за визначеним правилом. У загальному випадку алгоритм сортування за цим методом наведений у <strong>при­кладі 1.4</strong>. Розглянемо його більш детально.
</p>

<p>
Нагадаємо головні складові методу «пухирця»:
</p>

<ul>
<li>крок сортування містить перегляд елементів масиву з по­чатку до кінця, при цьому розглядаються пари сусідніх елементів;</li>
<li>елементи деякої пари міняються місцями у випадку, коли їх послідовність розташування не відповідає умові сортуван­ня (за зростанням або за спаданням).</li>
</ul>
<p>
<strong>Приклад 6.11.</strong> Упорядкувати за зростанням методом &#8220;пухирця&#8221; масив <strong>x<sub>і</sub> (і = 0&#8230;n-1), n = 5</strong>, що має значення:
</p>

<p>
<strong>x<sub>0</sub> = 25; x<sub>1</sub> = 37; х<sub>2</sub> = 0; х<sub>3</sub> = 10; х<sub>4</sub> = 2.</strong>
</p>

<p>
Слід зауважити, що <strong>жоден метод сортування не</strong> <strong>досягає результату за один перегляд масиву, для цього застосову­ється, як правило, цикл у циклі.</strong>
</p>

<p>
В алгоритмі сортування за методом «пухирця» (<strong>див. рис. 6.6.</strong>) з цією метою використано зовнішній цикл (цикл кроків сорту­вання) за параметром <strong>k</strong> та внутрішній цикл (цикл порівнянь перестановок) за параметром<strong> і</strong>. Оскільки кількість кроків сорту­вання має бути <strong>n-1</strong>, то параметр <strong>k </strong>зовнішнього циклу змінюеть­ся від 1 до <strong>n-1</strong> включно. На кожному кроці сортування у цик­лі за параметром<strong> і </strong>відбувається порівняння пар сусідніх елемен­тів та їх перестановка у випадку, коли пара розташована не за зростанням. Параметр<strong> і</strong> відповідає номеру елемента масиву.
</p>

<p>
<strong>Перший крок сортування</strong> <strong>(k = 1)</strong> здійснюється так:
</p>

<ul>
<li>послідовно порівнюються пари сусідніх елементів («25» «37») і, якщо перший елемент більше за другий, вони міняються місцями, тобто на друге місце, як пухирець, «спливае» більший з двох елементів (у даному випадку елементи залишаються на своїх місцях, елемент, що «спливає», виділенні шрифтом):</li>
<li>потім другий елемент («37»), більший з двох, порівнюється з третім елементом («0»), і на третє місце «спливає» більший з трьох («37»):</li>
<li>далі третій елемент («37») порівнюється з четвертим елементом («10»):</li>
<li>перегляд продовжується до кінця масиву, і найбільший елемент «спливе» та займе останнє місце у масиві:</li>
</ul>
<p>
<a href="http://cpp.dp.ua/uploads/posts/2015-12/1450820334_6_4.png"><img loading="lazy" class="aligncenter size-medium" src="http://cpp.dp.ua/uploads/posts/2015-12/1450820334_6_4.png" width="1343" height="1456" /></a>
<strong>Другий крок сортування (k = 2)</strong>, у результаті якого «спливає» вправо на передостаннє місце наступний найбільший елемент, дає таке розміщення елементів:
</p>

<p>
<strong>Третій крок сортування (k = 3)</strong> дозволяє розташувати наступний за величиною елемент третім справа:
</p>

<p>
І  далі останній <strong>четвертий крок сортування (k = 4)</strong> дає результат:
</p>

<p>
Сортування масивів за методом «пухирця» є найменш ефективним, середня кількість порівнянь дорівнює <strong>(n<sup>2</sup> &#8211; n)/2</strong>. Незважаючи на це, метод залишається одним з найпопулярніших завдяки простоті реалізації.
</p>

<p>
Особливості застосування методу «пухирця»:
</p>

<ul>
<li>алгоритми сортування, як за зростанням, так і за спаданням елементів, майже однакові, відрізняються вони тільки знаками порівняння, тобто, наприклад, замість <strong>xі &gt; х<sub>і+1</sub></strong> слід записати прямо протилежне — <strong>x<sub>i</sub> &lt; х<sub>і+1</sub></strong></li>
<li>присутність однакових елементів у масиві не додає проблем: у момент порівняння обидва елементи залишаються ні своїх місцях, а потім послідовно зміщуються по ряду та займають своє остаточне місце на сусідніх позиціях.Наведемо другий варіант програмної реалізації прикладу (<strong>див. Р6_11_2.СРР</strong>), в якому ім’я масиву використано як покажчик на його перший елемент:</li>
</ul>
<pre>
/* Рr6_11 _2.СРР — сортировка одномерного массива по возрастанию методом «пузырька» */
//--------------- использование имени массива как указателя
#inchide &lt;iostream.h&gt;
#include &lt;conio.h&gt;
main( )
{ const int n = 5;
  int x[n], i, k;  int а;       /* а — рабочая переменная для перестановки местами двух элементов */
//----------- ввод исходного массива
  for (і = 0; і &lt; n; i++)
   сіn &gt;&gt; *(x+i);
//----------- вывод на экран исходного массива
  cout &lt;&lt; "\n massiv х[n] \n";
  for (i = 0; i &lt; n; i++) 
  cout &lt;&lt; *(x+i) &lt;&lt; " "; 
//------------- сортировка no возрастанию
  for (k = 1; k &lt; n; k++)       // цикл шагов сортировки
    for (і = 0; і &lt; n-k; і++)    /* цикл сравненья элементов и их перестановки */
    if (*(x+i) &gt; *(x+i+1))   
    { а = *(x+i);
     *(x+i) = *(x+i+1);
     *(x+i+1) = a; }
  cout &lt;&lt; "\n Result sortirovki massiva " &lt;&lt; endl;
  for (i=0; і &lt; n; i++) 
  cout &lt;&lt; *(x+i) &lt;&lt; " ";
  getch();  
}
</pre>

<p>
<strong>Приклад 6.12.</strong> Для матриці <strong>matr(5,6)</strong> знайти суми елементів кожного рядка та записати їх в одновимірний масив. Стриманий масив відсортувати за зростанням методом «пухирця».
</p>

<pre>
// Р6 12.СРР - использование двумерных массивов 
/* занесение сумм элементов строк матрицы в массив и сортировка его по возрастанию методом "пузырька" */
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
void main()
  { int matr[5][6], mas[5];      // mas[ ] — массив сумм  строк   
    int і, j, sum, stk;
//--------------------- ввод матрицы matr(5,6)
  cout &lt;&lt; "Vvod matr[5][6] \n";
  for (і = 0; і &lt; 5; і++)  
    for (j = 0; j &lt; 6; j++)
    cin &gt;&gt; matr[i][j];
//--------------- формирование массива сумм элементов строк
  for (і = 0; sum = 0; і &lt; 5; і++)  
  { // нахождение суммы элементов строки
    for (j = 0; j &lt; 6; j++)
    sum += matr[i][j];
    mas[i] = sum }       //занесение суммы строки в массив
  cout &lt;&lt; "\nMassiv summ el. strok" &lt;&lt; endl; 
  for (і = 0; і &lt; 5; i++) 
  cout &lt;&lt; mas[i] &lt;&lt; " ";
//------------------ сортировка массива сумм по возрастанию
  for (і = 1;   і &lt; 5; і++)           // цикл шагов сортировки 
    for (j = 0; j &lt; 5-і; j++)      // цикл сравнен. и перестан. элем.
    if (mas[j] &gt; mas[j+1])
    { stk = mas[j];          // stk — для перестановки элементов 
      mas[j] = mas[j+1];     
      mas[j+1] = stk; }  
  cout &lt;&lt; "\nOtsortirovanniy massiv \n";
  for (i = 0; і &lt; 5; i++) 
  cout &lt;&lt; mas[i] &lt;&lt; " ";
  getch();            //задержка экрана вывода результата
}
</pre>

<p>
Результати обчислень:
</p>
<pre>
Vvod matr[5][6]
1 6 4 9 3 2
2 8 5 7 3 1
0 7 5 0 3 2
6 3 9 2 9 4
0 4 8 3 9 2
Massiv summ elementov strok 
25 26 21 33 31
Otsortirovanniy massiv
21 25 26 31 33
</pre>
<p>
У програмі використані типові прийоми алгоритмізації &#8211; накопичення суми <strong>sum</strong> та формування робочого масиву <strong>masj</strong>, що запам&#8217;ятовує суми елементів кожного рядка матриці. Застосування цих прийомів докладно пояснене відповідно у <strong>прикладі 1.2</strong> та <strong>прикладі 1.5.</strong> Кількість елементів створеного масиву дорівнює кількості рядків матриці. Для сортування отриманого масиву за зростанням використано сортування методом «пухирця».
</p>

<h4 style="text-align: center;"><span style="color: #ff0000;"><a style="color: #ff0000;" href="http://cpp.dp.ua/sortuvannya-bulbashkoyu/">Фрагмент лекції професора Девіда Малана із курса CS50 сортування &#8220;бульбашкою&#8221;</a></span></h4>
<p>
<strong>Сортування за методом вибору</strong> розглянемо на прикладі.
</p>

<p>
<strong>Приклад 6.13.</strong> Упорядкувати за зростанням методом вибору вихiдний масив, що має такі значення:
</p>

<p>
<strong>x<sub>0</sub> = 20; x<sub>1</sub> = 1; х<sub>2</sub> = 30; х<sub>3</sub> = 2; х<sub>4</sub> = 7, х<sub>5</sub> = 5.</strong>
</p>

<p>
Схему алгоритму та програму реалізації даної задачі наведено на <strong>рис. 6.7.</strong>
</p>

<p>
Процес сортування за зростанням здійснюється за кроками. Позначимо номер кроку сортування параметром<strong> і</strong>. На кожному кроці шукається найменший елемент, що міняється місцями з елементом, номер якого збігається з номером кроку <strong>і</strong>.
</p>

<p>
<strong>Нульовий крок сортування</strong> <strong>(і = 0):</strong>
</p>

<p>
у процесі розгляду елементів масиву, починаючи з першого, знаходять найменший елемент («1») і розташовують його на місце першого елемента, а перший («20») — на місце мінімального. У результаті найменший елемент масиву потрапляє
<img src="http://cpp.dp.ua/uploads/posts/2015-12/1450820924_6_4_1.png" alt="" />
на нульову позицію, тобто на перше місце зліва (підкресленi елементи, що переставляються):
</p>

<p style="text-align: center;"><img title="" src="http://cpp.dp.ua/uploads/posts/2015-12/1450821131_6_4_2.png" alt="" />
</p>

<p>
  <strong>Перший крок сортування (і = 1):</strong>
</p>

<p>
наступний найменший елемент («2»)знаходять у частинi масиву, що починається з першої позиції. Він міняється місцями з другим елементом («20»), тобто другий за значенням елмент («2») розташується на першій позиції, а саме на другому місці зліва:
</p>

<p style="text-align: center;"><img title="" src="http://cpp.dp.ua/uploads/posts/2015-12/1450821231_6_4_3.png" alt="" />
</p>

<p>
<strong>Другий крок сортування</strong> <strong>(і = 2):</strong>
третій за значенням елемент («5») знайдемо у масиві, починаючи з другої позиції («З0»), та поміняємо його місцем з елементом  масиву, що розташувався на другій позиції:
</p>

<p style="text-align: center;"><img title="" src="http://cpp.dp.ua/uploads/posts/2015-12/1450821238_6_4_4.png" alt="" />
</p>

<p>
Подальші кроки сортування дають такі перетворення: <strong>третій крок сортування</strong> <strong>(і = 3):</strong>
</p>

<p style="text-align: center;"><img title="" src="http://cpp.dp.ua/uploads/posts/2015-12/1450821258_6_4_5.png" alt="" />
</p>

<p>
<strong>Четвертий крок сортування (і=4):</strong>
</p>

<p style="text-align: center;"><img title="" src="http://cpp.dp.ua/uploads/posts/2015-12/1450821360_6_4_6.png" alt="" />
</p>

<p>
У результаті маємо відсортований за зростанням масив:
</p>

<p style="text-align: center;"><img title="" src="http://cpp.dp.ua/uploads/posts/2015-12/1450821340_6_4_7.png" alt="" />
</p>

<p>
Загальна кількість дій алгоритму сортування за методом вибору дорівнює <strong>(n<sup>2</sup>/4 + 3*n)</strong> операціям.
</p>

<h4 style="text-align: center;"><span style="color: #ff0000;"><a style="color: #ff0000;" href="http://cpp.dp.ua/sortuvannya-vyborom/">Фрагмент лекції професора Девіда Малана із курса CS50 сортування вибором</a></span></h4>
<p>
Сортування за методом вставки полягає в тому, що на кожному кроці відбувається вставка елемента у відсортований масив. Розглянемо цей метод на конкретному прикладі.
</p>

<p>
<strong>Приклад 6.14.</strong> Упорядкувати за зростанням (за спаданням) методом  вставки масив <strong>а<sub>і</sub> (і = 0&#8230;n-1), n = 6</strong>, що має такі значення:
</p>

<p>
<strong>a<sub>0</sub> = 4; а<sub>1</sub> = 13; a<sub>2</sub> = -3; а<sub>3</sub> = 6; a<sub>4</sub> = <sup>_</sup>8, a<sub>5</sub> = 24.</strong>
</p>

<p>
Схему алгоритму та програму реалізації цієї задачі наведено на <strong>рис. 6.8.</strong>
<a href="http://cpp.dp.ua/uploads/posts/2015-12/1450906389_6_4_9.png"><img loading="lazy" class="aligncenter size-medium" src="http://cpp.dp.ua/uploads/posts/2015-12/1450906389_6_4_9.png" width="1345" height="1701" /></a>
<strong>Сутність алгоритму сортування за методом вставки:</strong>
</p>

<ul>
<li>якщо <strong>j (а<sub>0</sub>&#8230;а<sub>j</sub><sub>-1</sub>)</strong> елементів масиву а відсортовані за зрос­танням, а елемент <strong>a<sub>j</sub></strong> має довільне значення, потрібно порівнювати цей елемент по черзі з елементами <strong>а<sub>j</sub><sub>-1</sub>, a<sub>j</sub><sub>-2</sub>,…</strong>, доки для <strong>a<sub>j</sub></strong> не знайдеться місце у відсортованому масиві. При цьому всі розглянуті елементи <strong>a<sub>j</sub><sub>-1</sub>, a<sub>j-2</sub></strong> <strong>,&#8230;</strong>,що будуть за значенням більш ніж <strong>a<sub>j</sub></strong> , мають переміститися на одну позицію вправо;</li>
<li>у випадку, коли елемент-вставка aj виявиться більше за значенням , ніж <strong>а<sub>j</sub><sub>-1</sub></strong>, елемент <strong>a<sub>j</sub></strong> залишиться на своєму місці. Якщо <strong>a</strong><sub>j</sub> буде менше всіх елементів <strong>а<sub>0</sub>&#8230;а<sub>j</sub><sub>-1</sub></strong>, то всі елементи мають бути переміщені на одну позицію вправо, a <strong>a<sub>j</sub></strong> займе місце <strong>j = 0</strong>. Що при переміщенні вправо не загубити значення елемента-вставки a<sub>j</sub>, потрібно завчасно зберегти його в робочій змінній (<strong>rab</strong>)</li>
</ul>
<p>
У програмі параметр і зовнішнього циклу відповідає за номер елемента-вставки, тому на першому кроці <strong>(і = 1)</strong> вважаємо що відсортований масив, до якого вставляється елемент <strong>rab = a<sub>j</sub></strong> складається тільки з одного елемента, на наступному кроці <strong>(і  = 2)</strong> маємо відсортований масив з двох елементів, а вставляємо до нього елемент <strong>а<sub>2</sub></strong> і так далі.
</p>

<p>
У внутрішньому циклі програми за параметром <strong>j</strong> відбувається порівняння елемента-вставки <strong>rab</strong> з елементами відсортованого масиву і переміщення цих елементів вправо, якщо за значенням вони більші, ніж <strong>rab</strong>. Безпосередньо вставка відбувається у зовнішньому циклі: <strong>a<sub>j</sub> = rab.</strong>
</p>

<p>
З розглянутих методів сортування цей метод — найефективніший, середня кількість операцій приблизно дорівнює <strong>n<sup>2 </sup>/ 4.</strong> Наведемо ще один варіант (<strong>див. Р6_14_2.СРР</strong>) програмної реалізації сортування масиву за спаданням елементів з використанням методу вставки, в якій використано покажчики та застосовано цикл while для пошуку мiсця елемента вставки.
</p>

<pre>
//Р6_14_2.СРР — сортировка методом вставки (по убыванию)
//---------------------- использование указателей
#include &lt;iostream.h&gt; 
#include &lt;conio.h&gt;
const int n=6; 
main ( )  
{ int a [n], i, j, rab;
  int *pmas; 
   pmas = a;      // pmas - &amp;a[0]; — указатель на начало массивам
 cout &lt;&lt; "***** Введите 6 элементов массива" &lt;&lt; endl;
 for (і = 0; і &lt; n; i++)
   cin &gt;&gt; *pmas++; 
  pmas = a;      //pmas -= n; — указатель на начало массивa
  for (і = 1; і &lt; n; і++)
   { rab= *(pmas + і); 
    j = і;      
    while (j &gt; 0 &amp;&amp; rab &gt; *(pmas + j-1))    
    { *(pmas + j) = *(pmas + j-1); 
       j-- }      
  *(pmas + j) = rab; }      
  cout &lt;&lt; "Отсортированный массив по убыванию" &lt;&lt; endl;      
  for (і = 0; і &lt; n; i++) 
  cout &lt;&lt; *(pmas + i) &lt;&lt; " ";          
 getch();  
}
</pre>

<p>
Результати виконання програми:
</p>

<pre>
Введите 6 элементов массива 
4 12 -3 6 -8 24
Отсортированный массив по убыванию
24 12 6 4 -3 -8
</pre>

<h4 style="text-align: center;"><a href="http://cpp.dp.ua/sortuvannya-vstavkoyu/"><span style="color: #ff0000;">Фрагмент лекції професора Девіда Малана із курса CS50 сортування вибором</span></a></h4>
<p>
<strong>Приклад 6.15.</strong> З двох впорядкованих за зростанням масивів <strong>a<sub>i</sub> (i = 0...n-1) і b<sub>j</sub> (j = 0&#8230;m-1)</strong> сформувати третій, також впорядкований, масив без додаткового сортування <strong>(n = 8, m = 12).</strong>
</p>

<p>
Алгоритм <strong>злиття двох відсортованих масивів</strong> (<strong>див. рис. 6.9)</strong> починається з порівняння перших елементів відповідних масивiв <strong>а і b</strong>. За лічильником і будемо вибирати елементи з масиву <strong>а</strong>, за лічильником  <strong>j</strong> — з масиву <strong>b</strong>, а за параметром  <strong>k</strong> — заносити елементи до масиву с. У масив с заноситься менший з елементів, що порівнюються, а далі в порівнянні бере участь наступний елемент того масиву, елемент якого вже записаний до с. Ця процедура повторюється, доки один з масивів не закiнчиться. Наприкінці слід тільки переписати до масиву с всі елементи іншого масиву, що залишилися.
<a href="http://cpp.dp.ua/uploads/posts/2015-12/1450821386_6_4_8.png"><img loading="lazy" class="aligncenter size-medium" src="http://cpp.dp.ua/uploads/posts/2015-12/1450821386_6_4_8.png" width="1327" height="1482" /></a>
</p>

<pre>
/* Р6_15.СРР — из двух массивов, отсортированных по возрастанию, сформировать третий */
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
const int n=8, m=12;
void main()
{ int a[n], b[m], c[n+m];
  int i, j, k, 1;
//--------------- ввод двух отсортированных массивов
cout &lt;&lt; "Vvedite 2 otsortirovanih massiva" &lt;&lt; endl;
  for (i = 0; і &lt; n; i++) 
  cin &gt;&gt; a[i];
  for (j = 0; j &lt; m; j++)  
  cin &gt;&gt; b[j];
//------------------- слияние массивов a и b в массив с
 for (і = 0, j = 0, к = 0; і &lt; n &amp;&amp; j &lt; m; k++)  
  if (a[i] &lt; b[j]) c[k] = a[i++];  
  else c[k] = b[j++];  
  if (i = = n)    
  for (l = k; l &lt; n+m; l++) 
  c[l] = b[j++];  
  else 
  for (l = k; l &lt; n+m; l++) 
  c[l] = a[i++];
//-------------- вывод полученного массива с
  cout &lt;&lt; "Rezult — massiv c" &lt;&lt; endl;
  for (і = 0; і &lt; n+m; i++) 
  cout &lt;&lt; c[i] &lt;&lt; " ";
  getch();
}
</pre>

<p>
Результати обчислень:
</p>
<pre>
Vvedite 2 otsortirovanih massiva
1 4 11 17 33 54 60 62
1 5 9 14 15 19 20 23 44 48 72 80
Rezult — massiv c
1 2 4 5 9 11 14 15 17 19 20 23 33 44 48 54 60 62 72 80
Ефективний метод сортування великих масивів — <strong>швидке cортування</strong> — розглянутий у підрозділі <strong>«Рекурсивні функції»</strong>
</pre>



<h2>Динамічні масиви</h2>

<p>
В основній пам’яті дані можуть зберігатися двома способами
</p>

<ul>
<li>пам’ять виділяється або в сегменті стека і залишається закріпленою до завершення виконання конкретної функції, або виділяється в сегменті даних на весь час виконання програми;</li>
<li>пам’ять виділяється в міру потреби (динамічне виділення  пам’яті).</li>
</ul>
<p>
Слід зазначити, що всі приклади, розглянуті раніше, де­монструють роботу з даними, які зберігаються першим способом.
</p>

<p>
<strong>Динамічна пам’ять</strong> — це вільна пам’ять, у якій під час ви­конання програми можна виділяти місце залежно від потреб користувача. <strong>Доступ до виділених ділянок динамічної пам&#8217;я­ті, що називаються динамічними змінними, здійснюєть­ся</strong> <strong>тільки через покажчики.</strong> Час існування динамічних змін­них — від початку створення до кінця програми або до явного звільнення пам’яті. У мові C++ застосовують два способи ро­боти з динамічною пам’яттю. Перший з них дістався в спад­щину від мови С і використовує сукупність функцій <strong>malloc()</strong>, другий — працює з операціями <strong>new та delete</strong>, які здійснюють динамічний розподіл і скасування з вищим пріоритетом, ніж інші функції.
</p>

<p>
Оператор <strong>new</strong> виділяє пам’ять і повертає її адресу. За допо­могою оператора <strong>delete</strong> відбувається звільнення пам’яті, на яку вказує змінна-покажчик.
</p>

<p>
Загальна форма запису оператора <strong>new</strong>:
</p>

<p>
<strong>змінна-покажчик = new тип змінної;.</strong>
</p>

<p>
Оператор <strong>delete</strong> має вигляд:
</p>

<p>
<strong>delete [ ] змінна-покажчик; </strong>.
</p>

<p>
Динамічні масиви створюють за допомогою операції new, при цьому необхідно вказати їх тип і розмірність. Наприклад, Для одновимірного масиву дійсних чисел, що має 100 елемен­тів, треба записати:
</p>

<p>
<strong>int n = 100;</strong>
</p>

<p>
<strong> float *р = new float[n];</strong> — змінна-покажчик на float виділяє у динамічній пам’яті ділянку для розміщення 100 елементів дійсного типу.
</p>

<p>
<strong>Слід пам’ятати, що динамічні масиви при створенні не можна ні ініціювати, ні обнуляти.</strong>
</p>

<p>
<strong>Приклад 6.16.</strong> З використанням динамічної пам’яті обробити вiдомість успішності групи студентів з дисципліни &#8220;Програмування&#8221; підрахувавши середній бал групи і кількість відмінників.
</p>

<pre>
/* P6_16.CPP использование динамической памяти при обработке одномерного массива */
#include &lt;iostream.h&gt;
#include &lt;conio.h&gt;
#include &lt;math.h&gt;
main ( )
{ const int n = 14;                // количество студентов
  int *mas;                         // объявление указателя на массив
  int і, k = 0;                      // k — количество отличников
  float s = 0;                      // s — сумма оценок группы
  mas = new int [n];             //выделение динамической памяти
cout &lt;&lt; " Ввод оценок " &lt;&lt; endl;
  for (і = 0; і &lt; n; і++)  
  сіn &gt;&gt; mas[i];
//---------------- подсчет суммы оценок и количества отличников
  for (і = 0; і &lt; n; і++)
  { s = s + mas[i];
    if (mas[i] == 5) 
    k = k+1; }
  cout &lt;&lt; endl; 
  cout.precision(3);
  cout &lt;&lt; "Средний балл = " &lt;&lt; s/n &lt;&lt; endl;
  cout &lt;&lt; "Количество отличников = " &lt;&lt; k &lt;&lt; endl;
  getch (); 
  delete[ ]mas;       // освобождение динамической памяти
}
</pre>

<p>
Результати обчислень:
</p>
<pre>
Ввод оценок
33345343245333
Средний балл = 3.43
Количество отличников = 2
</pre>

<p>
У цій програмі змінна <strong>s</strong> служить для обчислення суми oцiнок групи, а змінна <strong>k</strong> — для підрахунку кількості відмінників. Перед обчисленням треба надати цим змінним початкове нульове значення (накопичення суми і кількості пояснено у <strong>прикладах 1.1-1.2</strong>).
</p>

<p>
При створенні динамічного багатовимірного масиву необхiдно в операції <strong>new</strong> вказати всі його розмірності (перший може бути змінною), наприклад:
<strong>int n = 5;</strong> // n — количество строк
<strong>int **m = (int **) new int [n][5];.</strong>
</p>

<p>
Розглянемо більш універсальний і безпечний спосіб видiлення динамічної пам’яті під двовимірний масив, коли обидвi йгого розмірностізадаються на етапі виконання програми. Наприклад, розподіл динамічної пам’яті для матриці, що має <strong>n</strong> рядкiв і <strong>m</strong> стовпців та елементи цілоготипу, можна здійснити так:
</p>

<pre>
int n, m;
cout &lt;&lt; &#8221; Введите количество строк и столбцов: &#8220;;
cin &gt;&gt; n &gt;&gt; m;
int **a = new int *[n]; — оголошення змінної тип «покажчи на покажчик на int» і виділення пам’яті для масиву покажчиків на рядки матриці;
for (int і = 0; і &lt; n; і++)
a[і] = new int [m]; — кожному елементу масиву покажчиків на ряд­ки присвоюється адреса початку ділянки пам’яті, виділеної для ряд­ка матриці.
</pre>

<p>
Наочно це представлено на <strong>рис. 6.10.</strong>
<a href="http://cpp.dp.ua/uploads/posts/2015-12/1450895538_6_5.png"><img loading="lazy" class="aligncenter size-medium" src="http://cpp.dp.ua/uploads/posts/2015-12/1450895538_6_5.png" width="654" height="238" /></a>
Звільнення пам’яті з-під масиву будь-якої кількості вимірів виконується за допомогою операції <strong>delete[].</strong>
</p>

<p>
<strong>Приклад 6.17.</strong> З використанням динамічної пам’яті створити про­граму обчислення матриці С за формулою:
</p>

<p>
<strong>С [n][q] = A[n][m] * B[m][q].</strong>
</p>

<p>
Згідно з умовою, елемент матриці <strong>C[n][q]</strong> дорівнює сумі добутків елементів відповідного рядка матриці <strong>A[n][m]</strong> на елементи відповідного стовпця матриці
</p>

<p>
У запропонованій програмі для обчислення елементів добутку матриць організовано три вкладених цикли: цикл переборі рядків матриці <strong>А</strong>, цикл перебору стовпців матриці <strong>В</strong>, а також цикл накопичення суми для одержання елемента матриці <strong>С</strong>. Для виділення динамічної пам’яті під двовимірні масиви <strong>A[n][m], B[m][q] і С [n][q]</strong> скористаємося розглянутим вищі способом.
</p>

<pre>
/* Р6_17.СРР — использование динамической памяти при работе с матрицами */
#include &lt;iostream.h&gt;
#include &lt;math.h&gt;
#include &lt;conio.h&gt;
main ( )
{ int і, j, k; 
  int n, m, q;
  cout &lt;&lt; " Введите размерности матриц: \n";
  cout &lt;&lt; " n = " ; 
  cin &gt;&gt; n;
  cout &lt;&lt; " m = " ; 
  cin &gt;&gt; m;
  cout &lt;&lt; " q = " ; 
  cin &gt;&gt; q;
//----------------- создание динамических массивов
/* выделение динамической памяти под массивы указателей и инициализация массивов указателей */
  int **С = new int *[n];
  for (int і = 0; і &lt; n; і++)
  C[i] = new int [q];
  int **A = new int *[n];
  for (int і = 0; і &lt; n; i++)
  A[i] = new int [m];
  int **B = new int *[m];
  for (int і = 0; і &lt; m; i++)
  B[i] = new int [q];
//------------------------------ ввод матриц A[n][m] и B[m][q]
 cout&lt;&lt;"\n Ввод матрицы A[n][m] \n";
  for (і = 0; і &lt; n; і++)
    for (j = 0; j &lt; m; j++) 
    сіn &gt;&gt; *(А[i] + j);
    cout &lt;&lt; "\n Ввод матрицы B[m][q] \n”;
  for (i = 0; і &lt; m; i++) 
    for (j = 0; j &lt; q; j++) 
    cin &gt;&gt; *(B[i] + j);
//----------------------- вычисление матрицы C[n][q] = A[n][m]*B[m][q]
  for (і = 0; і &lt; n; i++)  // перебор строк матрицы A[n][m]
    for (k = 0; k&lt;q; k++) //перебор столбцов матрицы B[m][q]
    { C[i][k] = 0; 
      for (j = 0; j &lt; m; j++)
      C[i][k] += (A[i][j]* B[j][k]); // определение элемента C[i][k]
    }//-------------------- вывод на экран матрицы С[n][q]
  cout &lt;&lt; "\n Матрица C[n][q] = A[n][m] * B[m][q] \n";
  for (і = 0; і &lt; n; i++)
  { for (j = 0; j &lt; q; j++)  
    cout &lt;&lt; *(C[i] + j) &lt;&lt; " ";
    cout &lt;&lt; endl;}
  delete [ ]A; 
  delete [ ]B; 
  delete [ ]C;   // освобождение памяти
 getch (); 
}
</pre>

<p>
Результати обчислень:
</p>
<pre>
Введите размерности матриц:
n = 4 
m = З 
q = 5
Ввод матрицы A[n][m]
1 1 1
3 3 3
2 2 2
4 4 4
Ввод матрицы B[m][q]
8  8  8  8  8
7  7  7  7  7
5  5  5  5  5
Матрица C[n][q] = A[n][m] * B[m][q]
20 20 20 20 20
60 60 60 60 60
40 40 40 40 40
80 80 80 80 80
</pre>



			<h2>Контрольні запитання</h2>
			<ol>
				
 


<li>Що таке масив та які існують різновиди масивів?</li>

<li>Як здійснюється звернення до елементів масивів?</li>

<li>Як у С++ реалізується введення-виведення елементів масиву?</li>

<li>Охарактеризуйте поняття «покажчик» та наведіть приклади.</li>

<li>Які операції дозволені для змінних-покажчиків?</li>

<li>Що таке масиви покажчиків та які особливості їх використання?</li>

<li>Охарактеризуйте алгоритм сортування за методом «пухирця».</li>

<li>Охарактеризуйте алгоритми сортування за методом вибору.</li>

<li>Охарактеризуйте поняття «динамічна пам’ять» та и можливості.</li>

<li>Як обробляються масиви з використанням динамічної пам’яті?</li>


			</ol>
		</div>
	</body>
	</html>