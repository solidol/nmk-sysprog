[Перелік усіх робіт](README.md)

# 16. Створення класів

## Мета роботи 

Отримати практичні навички реалізації класів С++

## Обладнання

Персональний комп’ютер, Visual Studio 2008 або інша середа розробки для мови C++

## Теоретичні відомості

### Клас.

З погляду синтаксису, клас у С++ це структурований тип, утворений на основі вже існуючих типів. У класі відображено найважливіші концепції об'єктно-орієнтованого програмування: інкапсуляція, успадкування, поліморфізм.

У найпростішому випадку клас можна визначити за допомогою конструкції:

```
class ім'я_класу {
	список_членів_класу;
	список_членів_класу;
	список_членів_класу;
	список_членів_класу;
	список_членів_класу;
};
```
де

`тип_класу` – одне із службових слів `class`, `struct`, `union` ;

`ім'я_класу` – ідентифікатор;

`список_членів_класу` - Визначення та описи типізованих даних і належать класу функцій.

Функції – це методи класу, визначальні операції над об'єктом.

Дані – це поля об'єкта, які утворюють його структуру. Значення полів визначає стан об'єкта.
приклади.

```cpp
struct date{ // дата
	int month,day,year; // Поля: місяць, день, рік
	void set (int, int, int); //метод – встановити дату
	void get(int*,int*,int*); //метод – отримати дату
	void next(); //метод – встановити наступну дату
	void print(); // метод – вивести дату
};
```

```cpp
struct complex {// комплексне число
	double re,im;
	double real(){return(re);}
	double imag(){return(im);}
	void set(double x,double y){re = x; im = y;}
	void print(){cout<<"re = "<<re; cout<<"im = "<<im;}
};
```

Для опису об'єкта класу (екземпляра класу) використовується конструкція `ім'я_класу ім'я_об'єкта;`

```cpp
date today, my_birthday;
date *point = &today; // покажчик на об'єкт типу date
date clim [30]; // масив об'єктів
date &name = my_birthday; // Посилання на об'єкт
```

Об'єкти, що визначаються, входять дані, що відповідають членам - даним класу. Функції члени класу дозволяють обробляти дані конкретних об'єктів класу. Звертатися до даних об'єкта та викликати функції об'єкта можна двома способами. Перший за допомогою "кваліфікованих" імен:

`имя_объекта.имя_данного`
`имя_объекта.имя_функции`


Наприклад:
```cpp
complex x1, x2;
x1.re = 1.24;
x1.im = 2.3;
x2.set(5.1,1.7);
x1.print();
```

Другий спосіб доступу використовує покажчик на

`об'єкт_>об'єкт->ім'я_компонента`

```cpp
complex *point = &x1; // чи point = new complex;
point->re = 1.24;
point->im = 2.3;
point->print ();
```

### Доступність компонентів класу.

У розглянутих прикладах класів компоненти класів є загальнодоступними. У будь-якому місці програми, де "видно" визначення класу, можна отримати доступ до компонентів об'єкта класу. Тим самим не виконується основний принцип абстракції даних – інкапсуляція (приховування) даних усередині об'єкта. Для зміни видимості компонентів у визначенні класу можна використовувати специфікатори доступу: public, private, protected .

Загальнодоступні компоненти (public) доступні в будь-якій частині програми. Вони можуть використовуватися будь-якою функцією як усередині даного класу, так і поза ним. 

Власні (private) компоненти локалізовані в класі і не доступні ззовні. Вони можуть використовуватись функціями – членами даного класу та функціями – "друзями" того класу, в якому вони описані.

Захищені (protected) компоненти доступні всередині класу та у похідних класах.

Змінити статус доступу до компонентів класу можна за допомогою використання у визначенні класу ключового слова class . І тут всі компоненти класу за промовчанням є власними. 
```cpp
class complex{
	double re, im; // private за замовчуванням
	public:
	double real(){return re;}
	double imag(){return im;}
	void set(double x,double y){re = x; im = y;}
};
```

### Конструктор.

Недоліком розглянутих раніше класів є відсутність автоматичної ініціалізації створюваних об'єктів. До кожного новоствореного об'єкта потрібно було викликати функцію типу set (як класу complex) чи явно присвоювати значення даним об'єкта. Однак для ініціалізації об'єктів класу в його визначення можна явно включити спеціальну функцію компоненту, звану конструктором. Формат визначення конструктора наступний:
```
ім'я_класу(список_форм_параметрів){
	оператори_тіла_конструктора;
	оператори_тіла_конструктора;
	оператори_тіла_конструктора;
}
```

Ім'я цієї компонентної функції за правилами мови С++ має співпадати з ім'ям класу. Така функція автоматично викликається при визначенні чи розміщенні у пам'яті за допомогою оператора new кожного об'єкта класу.
приклад.
```cpp
сomplex(double re1 = 0.0, double im1 = 0.0) {
	re = re1; im = im1;
}
```

Конструктор виділяє пам'ять для об'єкта та ініціалізує дані члени класу.

Конструктор має низку особливостей:


>Для конструктора не визначається тип значення, що повертається. Навіть тип void не допустимий.

>Покажчик на конструктор не може бути визначений, і відповідно не можна отримати адресу конструктора.

>Конструктори не успадковуються.

>Конструктори не можуть бути описані з ключовими словами virtual, static, const, mutuable, valatile.


Конструктор завжди існує для будь-якого класу, причому якщо він не визначений явно, він створюється автоматично.

Параметром конструктора може бути його власний клас, але може бути посилання нього (T&). Без явної вказівки програміста конструктор завжди автоматично викликається щодо (створенні) об'єкта. І тут викликається конструктор без параметрів. Для явного виклику конструктора використовуються дві форми:

ім'я класу ім'я об'єкта (фактичні параметри);

ім'я_класу (фактичні_параметри);

Перша форма допускається лише за не порожньому списку фактичних параметрів. Вона передбачає виклик конструктора щодо нового об'єкта даного класу:

complex ss (5.9,0.15);

Друга форма виклику призводить до створення об'єкта без імені: *

complex ss = complex (5.9,0.15);

Існують два способи ініціалізації даних об'єкта за допомогою конструктора. Раніше ми розглядали перший спосіб, а саме, передача значень параметрів тіло конструктора. Другий спосіб передбачає застосування списку ініціалізаторів цього класу. Цей список міститься


між списком параметрів та тілом конструктора. Кожен ініціалізатор списку відноситься до конкретного компонента і має вигляд:

ім'я_даного (вираз)


Приклади.


Клас "символьний рядок".
```cpp
#include <string.h>
#include <iostream>

class string{
	char *ch; // покажчик на текстовий рядок
	int len; // Довжина текстового рядка
	public:
	// Конструктори
	// створює об'єкт - порожній рядок
	string (int N = 80): len (0) {
		ch = new char [N + 1]; 
		ch[0] = '\0';
	}
	// створює об'єкт за заданим рядком
	string (const char * arch) {
		len = strlen (arch);
		ch = new char[len +1];
		strcpy(ch,arch);
	}

	// компоненти-функції
	// повертає посилання на довжину рядка
	int& len_str(void){
		return len;
	}
	// повертає покажчик на рядок
	char *str(void){
		return ch;
	}
};
```

Тут у класу string два конструктори - функції, що перевантажуються.

За замовчуванням створюється конструктор копіювання виду T::T(const T&), де Т – ім'я класу. Конструктор копіювання викликається щоразу, коли виконується копіювання об'єктів, що належать класу. Зокрема, він викликається:


а) коли об'єкт передається функції за значенням;

б) при побудові тимчасового об'єкта як значення функції, що повертається;

в) під час використання об'єкта для ініціалізації іншого об'єкта.

Якщо клас не містить певним чином конструктора копіювання, то при виникненні однієї з цих ситуацій проводиться побітове копіювання об'єкта. Побітове копіювання не завжди є адекватним. Саме для таких випадків необхідно визначити власний конструктор копіювання. Наприклад, у класі string:

string(const string&st)

{len=strlen(st.len);

ch=new char[len+1];

strcpy(ch,st.ch); }


Можна створювати масив об'єктів, однак відповідний клас повинен мати конструктор за замовчуванням (без параметрів).

Масив об'єктів може ініціалізуватися або автоматично за замовчуванням конструктором, або явним присвоєнням значень кожному елементу масиву.

class demo{

int x;

public:

demo(){x=0;}

demo(int i){x=i;}

};

void main () {

class demo a [20]; //виклик конструктора без параметрів(за замовчуванням)

class demo b[2]={demo(10),demo(100)};//явне присвоєння


Деструктор.

Динамічне виділення пам'яті для об'єкта створює необхідність звільнення пам'яті при знищенні об'єкта. Наприклад, якщо об'єкт формується як локальний усередині блоку, то доцільно, щоб при виході з блоку, коли об'єкт перестає існувати, виділена для нього пам'ять була повернута. Бажано, щоб звільнення пам'яті відбувалося автоматично. Таку можливість забезпечує спеціальний компонент класу деструктор класу. Його формат:

ім'я_класу(){оператори_тіла_деструктора}


Ім'я деструктора збігається з ім'ям його класу, але передує символом "~" (тильда).

Деструктор не має параметрів і значення, що повертається. Виклик

деструктор виконується не явно (автоматично), як тільки об'єкт класу знищується.

Наприклад, при виході за область визначення або виклику оператора delete для вказівника на об'єкт.

string * p = new string "рядок");

delete p;

Якщо класі деструктор не визначено явно, то компілятор генерує деструктор за умовчанням, який просто звільняє пам'ять, зайняту даними об'єкта. У тих випадках, коли потрібно виконати звільнення та інших об'єктів пам'яті, наприклад, область, на яку вказує ch в об'єкті string, необхідно визначити деструктор явно: ~string(){delete []ch;}

Так само, як і для конструктора, не може бути визначений покажчик на деструктор.


^ Покажчики на компоненти-функції.

Можна визначити покажчик компонентів-функцій.

тип_повернення_значення(ім'я_класу::*ім'я_покажчика_на_функцію) (спеціф_параметрів_функції);

Приклад .

double(complex : :*ptcom)(); // Визначення покажчика

ptcom = & complex :: real; // Налаштування покажчика

// Тепер об'єкта А можна викликати його функцію

complex A(5.2,2.7);

cout<<(A.*ptcom)();


Можна також визначити тип покажчика на функцію

typedef double&(complex::*PF)();

а потім визначити сам покажчик

PF ptcom=&complex::real;


## Хід роботи

## Контрольні запитання


## Довідники та додаткові матеріали